{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pg_graphql Documentation : https://supabase.github.io/pg_graphql Source Code : https://github.com/supabase/pg_graphql pg_graphql adds GraphQL support to your PostgreSQL database. Performant Consistent Open Source Overview pg_graphql is a PostgreSQL extension that enables querying the database with GraphQL using a single a SQL function. The extension reflects a GraphQL schema from the existing SQL schema and exposes it through a SQL function, graphql.resolve(...) . This enables any programming language that can connect to PostgreSQL to query the database via GraphQL with no additional servers, processes, or libraries. TL;DR The SQL schema 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 create table account ( id serial primary key , email varchar ( 255 ) not null , created_at timestamp not null , updated_at timestamp not null ); create table blog ( id serial primary key , owner_id integer not null references account ( id ), name varchar ( 255 ) not null , description varchar ( 255 ), created_at timestamp not null , updated_at timestamp not null ); create type blog_post_status as enum ( 'PENDING' , 'RELEASED' ); create table blog_post ( id uuid not null default uuid_generate_v4 () primary key , blog_id integer not null references blog ( id ), title varchar ( 255 ) not null , body varchar ( 10000 ), status blog_post_status not null , created_at timestamp not null , updated_at timestamp not null ); Translates into a GraphQL schema displayed below. Each table receives an entrypoint in the top level Query type that is a pageable collection with relationships defined by its foreign keys. Tables similarly recieve entrypoints in the Mutation type that enable bulk operations for insert, update, and delete.","title":"Welcome"},{"location":"#pg_graphql","text":"Documentation : https://supabase.github.io/pg_graphql Source Code : https://github.com/supabase/pg_graphql pg_graphql adds GraphQL support to your PostgreSQL database. Performant Consistent Open Source","title":"pg_graphql"},{"location":"#overview","text":"pg_graphql is a PostgreSQL extension that enables querying the database with GraphQL using a single a SQL function. The extension reflects a GraphQL schema from the existing SQL schema and exposes it through a SQL function, graphql.resolve(...) . This enables any programming language that can connect to PostgreSQL to query the database via GraphQL with no additional servers, processes, or libraries.","title":"Overview"},{"location":"#tldr","text":"The SQL schema 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 create table account ( id serial primary key , email varchar ( 255 ) not null , created_at timestamp not null , updated_at timestamp not null ); create table blog ( id serial primary key , owner_id integer not null references account ( id ), name varchar ( 255 ) not null , description varchar ( 255 ), created_at timestamp not null , updated_at timestamp not null ); create type blog_post_status as enum ( 'PENDING' , 'RELEASED' ); create table blog_post ( id uuid not null default uuid_generate_v4 () primary key , blog_id integer not null references blog ( id ), title varchar ( 255 ) not null , body varchar ( 10000 ), status blog_post_status not null , created_at timestamp not null , updated_at timestamp not null ); Translates into a GraphQL schema displayed below. Each table receives an entrypoint in the top level Query type that is a pageable collection with relationships defined by its foreign keys. Tables similarly recieve entrypoints in the Mutation type that enable bulk operations for insert, update, and delete.","title":"TL;DR"},{"location":"api/","text":"In our API, each SQL table is reflected as a set of GraphQL types. At a high level, tables become types and columns/foreign keys become fields on those types. By default, PostgreSQL table and column names are not inflected when reflecting GraphQL names. For example, an account_holder table has GraphQL type name account_holder . In cases where SQL entities are named using snake_case , enable inflection to match GraphQL/Javascript conventions e.g. account_holder -> AccountHolder . Individual table, column, and relationship names may also be manually overridden . QueryType The Query type is the entrypoint for all read access into the graph. Node The node interface allows for retrieving records that are uniquely identifiable by a globally unique nodeId: ID! field. For more information about nodeId, see nodeId . SQL Setup 1 2 3 4 5 6 7 create table \"Blog\" ( id serial primary key , name varchar ( 255 ) not null , description varchar ( 255 ), \"createdAt\" timestamp not null , \"updatedAt\" timestamp not null ); GraphQL Types QueryType 1 2 3 4 5 6 7 \"\"\"The root type for querying data\"\"\" type Query { \"\"\"Retrieve a record by its `ID`\"\"\" node ( nodeId: ID !): Node } To query the node interface effectively, use inline fragments to specify which fields to return for each type. Example Query Response 1 2 3 4 5 6 7 8 9 10 11 12 { node ( nodeId: \"WyJwdWJsaWMiLCAiYmxvZyIsIDFd\" ) { nodeId # Inline fragment for `Blog` type ... on Blog { name description } } } 1 2 3 4 5 6 7 8 9 { \"data\" : { \"node\" : { \"name\" : \"Some Blog\" , \"nodeId\" : \"WyJwdWJsaWMiLCAiYmxvZyIsIDFd\" , \"description\" : \"Description of Some Blog\" } } } Collections Each table has top level entry in the Query type for selecting records from that table. Collections return a connection type and can be paginated , filtered , and sorted using the available arguments. SQL Setup 1 2 3 4 5 6 7 create table \"Blog\" ( id serial primary key , name varchar ( 255 ) not null , description varchar ( 255 ), \"createdAt\" timestamp not null , \"updatedAt\" timestamp not null ); GraphQL Types QueryType 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \"\"\"The root type for querying data\"\"\" type Query { \"\"\"A pagable collection of type `Blog`\"\"\" blogCollection ( \"\"\"Query the first `n` records in the collection\"\"\" first: Int \"\"\"Query the last `n` records in the collection\"\"\" last: Int \"\"\"Query values in the collection before the provided cursor\"\"\" before: Cursor \"\"\"Query values in the collection after the provided cursor\"\"\" after: Cursor \"\"\"Filters to apply to the results set when querying from the collection\"\"\" filter: BlogFilter \"\"\"Sort order to apply to the collection\"\"\" orderBy: [ BlogOrderBy !] ): BlogConnection } Connection types are the primary interface to returning records from a collection. Connections wrap a result set with some additional metadata. BlogConnection BlogEdge PageInfo Blog BlogOrderBy BlogFilter 1 2 3 4 5 6 7 8 9 10 11 12 type BlogConnection { # Count of all records matching the *filter* criteria totalCount: Int ! # Pagination metadata pageInfo: PageInfo ! # Result set edges: [ BlogEdge !]! } 1 2 3 4 5 6 7 8 9 type BlogEdge { # Unique identifier of the record within the query cursor: String ! # Contents of a record/row in the results set node: Blog } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 type PageInfo { # unique identifier of the first record within the query startCursor: String # unique identifier of the last record within the query endCursor: String # is another page of content available hasNextPage: Boolean ! # is another page of content available hasPreviousPage: Boolean ! } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # A record from the `blog` table type Blog { # globally unique identifier nodeId: ID ! # Value from `id` column id: Int ! # Value from `name` column name: String ! # Value from `description` column description: String # Value from `createdAt` column createdAt: Datetime ! # Value from `updatedAt` column updatedAt: Datetime ! } 1 2 3 4 5 6 7 input BlogOrderBy { id: OrderByDirection name: OrderByDirection description: OrderByDirection createdAt: OrderByDirection updatedAt: OrderByDirection } 1 2 3 4 5 6 7 8 input BlogFilter { nodeId: IDFilter id: IntFilter name: StringFilter description: StringFilter createdAt: DatetimeFilter updatedAt: DatetimeFilter } Note The totalCount field is disabled by default because it can be expensive on large tables. To enable it use a comment directive Pagination Paginating forwards and backwards through collections is handled using the first , last , before , and after parameters, following the relay spec . QueryType 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 type Query { blogCollection ( \"\"\"Query the first `n` records in the collection\"\"\" first: Int \"\"\"Query the last `n` records in the collection\"\"\" last: Int \"\"\"Query values in the collection before the provided cursor\"\"\" before: Cursor \"\"\"Query values in the collection after the provided cursor\"\"\" after: Cursor ... truncated ... ): BlogConnection } Metadata relating to the current page of a result set is available on the pageInfo field of the connection type returned from a collection. PageInfo BlogConnection 1 2 3 4 5 6 7 8 9 10 11 12 13 14 type PageInfo { # unique identifier of the first record within the query startCursor: String # unique identifier of the last record within the query endCursor: String # is another page of content available hasNextPage: Boolean ! # is another page of content available hasPreviousPage: Boolean ! } 1 2 3 4 5 6 7 8 9 type BlogConnection { # Pagination metadata pageInfo: PageInfo ! # Result set edges: [ BlogEdge !]! } To paginate forward in the collection, use the first and after aguments. To retrive the first page, the after argument should be null or absent. Example Query Page 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { blogCollection ( first: 2 , after: null ) { pageInfo { startCursor endCursor hasPreviousPage hasNextPage } edges { cursor node { id } } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 { \"data\" : { \"blogCollection\" : { \"edges\" : [ { \"node\" : { \"id\" : 1 }, \"cursor\" : \"WzFd\" }, { \"node\" : { \"id\" : 2 }, \"cursor\" : \"WzJd\" } ], \"pageInfo\" : { \"startCursor\" : \"WzFd\" , \"endCursor\" : \"WzJd\" , \"hasNextPage\" : true , \"hasPreviousPage\" : false } } } } To retrieve the next page, provide the cursor value from data.blogCollection.pageInfo.endCursor to the after argument of another query. Query Page 2 1 2 3 4 5 6 7 { blogCollection ( first: 2 , after: \"WzJd\" ) { ... truncated ... } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 { \"data\" : { \"blogCollection\" : { \"edges\" : [ { \"node\" : { \"id\" : 3 }, \"cursor\" : \"WzNd\" }, { \"node\" : { \"id\" : 4 }, \"cursor\" : \"WzRd\" } ], \"pageInfo\" : { \"startCursor\" : \"WzNd\" , \"endCursor\" : \"WzRd\" , \"hasNextPage\" : false , \"hasPreviousPage\" : true } } } } once the collection has been fully enumerated, data.blogConnection.pageInfo.hasNextPage returns false. To paginate backwards through a collection, repeat the process substituting first -> last , after -> before , hasNextPage -> hasPreviousPage Filtering To filter the result set, use the filter argument. QueryType 1 2 3 4 5 6 7 8 9 10 11 type Query { blogCollection ( \"\"\"Filters to apply to the results set when querying from the collection\"\"\" filter: BlogFilter ... truncated ... ): BlogConnection } Where the <Table>Filter type enumerates filterable fields and their associated <Type>Filter . BlogFilter IntFilter StringFilter 1 2 3 4 5 6 7 8 input BlogFilter { nodeId: IDFilter id: IntFilter name: StringFilter description: StringFilter createdAt: DatetimeFilter updatedAt: DatetimeFilter } 1 2 3 4 5 6 7 8 9 10 11 12 \"\"\" Boolean expression comparing fields on type \"Int\" \"\"\" input IntFilter { eq: Int gt: Int gte: Int in: [ Int !] lt: Int lte: Int neq: Int } 1 2 3 4 5 6 7 8 9 10 11 12 \"\"\" Boolean expression comparing fields on type \"String\" \"\"\" input StringFilter { eq: String gt: String gte: String in: [ String !] lt: String lte: String neq: String } The following list shows the operators that may be available on <Type>Filter types. Operator Description eq Equal To neq Not Equal To gt Greater Than gte Greater Than Or Equal To in Contained by Value List lt Less Than lte Less Than Or Equal To Not all operators are available on every <Type>Filter type. For example, UUIDFilter only supports eq and neq because UUID s are not ordered. Example Query Result 1 2 3 4 5 6 7 8 9 10 11 12 { blogCollection ( filter: { id: { lt: 3 }} , ) { edges { cursor node { id } } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 { \"data\" : { \"blogCollection\" : { \"edges\" : [ { \"node\" : { \"id\" : 1 }, \"cursor\" : \"WzFd\" }, { \"node\" : { \"id\" : 2 }, \"cursor\" : \"WzJd\" } ] } } } When multiple filters are provided to the filter argument, all conditions must be met for a record to be returned. In other words, multiple filters are composed with AND boolean logic. We expect to expand support to user defined AND and OR composition in a future release. Ordering The default order of results is defined by the underlying table's primary key column/s in ascending order. That default can be overridden by passing an array of <Table>OrderBy to the collection's orderBy argument. QueryType BlogOrderBy OrderByDirection 1 2 3 4 5 6 7 8 9 10 11 type Query { blogCollection ( \"\"\"Sort order to apply to the collection\"\"\" orderBy: [ BlogOrderBy !] ... truncated ... ): BlogConnection } 1 2 3 4 5 6 7 input BlogOrderBy { id: OrderByDirection name: OrderByDirection description: OrderByDirection createdAt: OrderByDirection updatedAt: OrderByDirection } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \"\"\"Defines a per-field sorting order\"\"\" enum OrderByDirection { \"\"\"Ascending order, nulls first\"\"\" AscNullsFirst \"\"\"Ascending order, nulls last\"\"\" AscNullsLast \"\"\"Descending order, nulls first\"\"\" DescNullsFirst \"\"\"Descending order, nulls last\"\"\" DescNullsLast } Example Query Result 1 2 3 4 5 6 7 8 9 10 11 { blogCollection ( orderBy: [{ id: DescNullsLast }] ) { edges { node { id } } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 { \"data\" : { \"blogCollection\" : { \"edges\" : [ { \"node\" : { \"id\" : 4 } }, { \"node\" : { \"id\" : 3 } }, { \"node\" : { \"id\" : 2 } }, { \"node\" : { \"id\" : 1 } } ] } } } Note, only one key value pair may be provided to each element of the input array. For example, [{name: AscNullsLast}, {id: AscNullFirst}] is valid. Passing multiple key value pairs in a single element of the input array e.g. [{name: AscNullsLast, id: AscNullFirst}] , is invalid. MutationType The Mutation type is the entrypoint for mutations/edits. Each table has top level entry in the Mutation type for inserting insertInto<Table>Collection , updating update<Table>Collection and deleting deleteFrom<Table>Collection . SQL Setup 1 2 3 4 5 6 7 create table \"Blog\" ( id serial primary key , name varchar ( 255 ) not null , description varchar ( 255 ), \"createdAt\" timestamp not null default now (), \"updatedAt\" timestamp ); MutationType 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 \"\"\"The root type for creating and mutating data\"\"\" type Mutation { \"\"\"Adds one or more `BlogInsertResponse` records to the collection\"\"\" insertIntoBlogCollection ( \"\"\"Records to add to the Blog collection\"\"\" objects: [ BlogInsertInput !]! ): BlogInsertResponse \"\"\"Updates zero or more records in the collection\"\"\" updateBlogCollection ( \"\"\" Fields that are set will be updated for all records matching the `filter` \"\"\" set: BlogUpdateInput ! \"\"\"Restricts the mutation's impact to records matching the critera\"\"\" filter: BlogFilter \"\"\" The maximum number of records in the collection permitted to be affected \"\"\" atMost: Int ! = 1 ): BlogUpdateResponse ! \"\"\"Deletes zero or more records from the collection\"\"\" deleteFromBlogCollection ( \"\"\"Restricts the mutation's impact to records matching the critera\"\"\" filter: BlogFilter \"\"\" The maximum number of records in the collection permitted to be affected \"\"\" atMost: Int ! = 1 ): BlogDeleteResponse ! } Insert To add records to a collection, use the insertInto<Table>Collection field on the Mutation type. SQL Setup 1 2 3 4 5 6 7 create table \"Blog\" ( id serial primary key , name varchar ( 255 ) not null , description varchar ( 255 ), \"createdAt\" timestamp not null default now (), \"updatedAt\" timestamp ); GraphQL Types MutationType BlogInsertInput BlogInsertResponse 1 2 3 4 5 6 7 8 9 10 11 12 \"\"\"The root type for creating and mutating data\"\"\" type Mutation { \"\"\"Adds one or more `BlogInsertResponse` records to the collection\"\"\" insertIntoBlogCollection ( \"\"\"Records to add to the Blog collection\"\"\" objects: [ BlogInsertInput !]! ): BlogInsertResponse } 1 2 3 4 5 6 input BlogInsertInput { name: String description: String createdAt: Datetime updatedAt: Datetime } 1 2 3 4 5 6 7 type BlogInsertResponse { \"\"\"Count of the records impacted by the mutation\"\"\" affectedCount: Int ! \"\"\"Array of records impacted by the mutation\"\"\" records: [ Blog !]! } Where elements in the objects array are inserted into the underlying table. Example Query Result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 mutation { insertIntoBlogCollection ( objects: [ { name: \"foo\" } , { name: \"bar\" } , ] ) { affectedCount records { id name } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { \"data\" : { \"insertIntoBlogCollection\" : { \"records\" : [ { \"id\" : 1 , \"name\" : \"foo\" }, { \"id\" : 2 , \"name\" : \"bar\" } ], \"affectedCount\" : 2 } } } Update To update records in a collection, use the update<Table>Collection field on the Mutation type. SQL Setup 1 2 3 4 5 6 7 create table \"Blog\" ( id serial primary key , name varchar ( 255 ) not null , description varchar ( 255 ), \"createdAt\" timestamp not null default now (), \"updatedAt\" timestamp ); GraphQL Types MutationType BlogUpdateInput BlogUpdateResponse 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \"\"\"The root type for creating and mutating data\"\"\" type Mutation { \"\"\"Updates zero or more records in the collection\"\"\" updateBlogCollection ( \"\"\" Fields that are set will be updated for all records matching the `filter` \"\"\" set: BlogUpdateInput ! \"\"\"Restricts the mutation's impact to records matching the critera\"\"\" filter: BlogFilter \"\"\" The maximum number of records in the collection permitted to be affected \"\"\" atMost: Int ! = 1 ): BlogUpdateResponse ! } 1 2 3 4 5 6 input BlogUpdateInput { name: String description: String createdAt: Datetime updatedAt: Datetime } 1 2 3 4 5 6 7 8 9 type BlogUpdateResponse { \"\"\"Count of the records impacted by the mutation\"\"\" affectedCount: Int ! \"\"\"Array of records impacted by the mutation\"\"\" records: [ Blog !]! } Where the set argument is a key value pair describing the values to update, filter controls which records should be updated, and atMost restricts the maximum number of records that may be impacted. If the number of records impacted by the mutation exceeds the atMost parameter the operation will return an error. Example Query Result 1 2 3 4 5 6 7 8 9 10 11 12 mutation { updateBlogCollection ( set: { name: \"baz\" } filter: { id: { eq: 1 }} ) { affectedCount records { id name } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 { \"data\" : { \"updateBlogCollection\" : { \"records\" : [ { \"id\" : 1 , \"name\" : \"baz\" } ], \"affectedCount\" : 1 } } } Delete To remove records from a collection, use the deleteFrom<Table>Collection field on the Mutation type. SQL Setup 1 2 3 4 5 6 7 create table \"Blog\" ( id serial primary key , name varchar ( 255 ) not null , description varchar ( 255 ), \"createdAt\" timestamp not null default now (), \"updatedAt\" timestamp ); GraphQL Types MutationType BlogFilter BlogDeleteResponse 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \"\"\"The root type for creating and mutating data\"\"\" type Mutation { \"\"\"Deletes zero or more records from the collection\"\"\" deleteFromBlogCollection ( \"\"\"Restricts the mutation's impact to records matching the critera\"\"\" filter: BlogFilter \"\"\" The maximum number of records in the collection permitted to be affected \"\"\" atMost: Int ! = 1 ): BlogDeleteResponse ! } 1 2 3 4 5 6 7 input BlogFilter { id: IntFilter name: StringFilter description: StringFilter createdAt: DatetimeFilter updatedAt: DatetimeFilter } 1 2 3 4 5 6 7 type BlogDeleteResponse { \"\"\"Count of the records impacted by the mutation\"\"\" affectedCount: Int ! \"\"\"Array of records impacted by the mutation\"\"\" records: [ Blog !]! } Where filter controls which records should be deleted and atMost restricts the maximum number of records that may be deleted. If the number of records impacted by the mutation exceeds the atMost parameter the operation will return an error. Example Query Result 1 2 3 4 5 6 7 8 9 10 11 mutation { deleteFromBlogCollection ( filter: { id: { eq: 1 }} ) { affectedCount records { id name } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 { \"data\" : { \"deleteFromBlogCollection\" : { \"records\" : [ { \"id\" : 1 , \"name\" : \"baz\" } ], \"affectedCount\" : 1 } } } Concepts nodeId The base GraphQL type for every table with a primary key is automatically assigned a nodeId: ID! field. That value, can be passed to the node entrypoint of the Query type to retrieve its other fields. nodeId may also be used as a caching key. relay support By default relay expects the ID field for types to have the name id . pg_graphql uses nodeId by default to avoid conflicting with user defined id columns. You can configure relay to work with pg_graphql's nodeId field with relay's nodeInterfaceIdField option. More info available here . SQL Setup 1 2 3 4 create table \"Blog\" ( id serial primary key , name varchar ( 255 ) not null ); GraphQL Types Blog 1 2 3 4 5 type Blog { nodeId : ID ! # this field id : Int ! name : String ! } Relationships Relationships between collections in the Graph are derived from foreign keys. One-to-Many A foreign key on table A referencing table B defines a one-to-many relationship from table A to table B. SQL Setup 1 2 3 4 5 6 7 8 9 10 11 create table \"Blog\" ( id serial primary key , name varchar ( 255 ) not null ); create table \"BlogPost\" ( id serial primary key , \"blogId\" integer not null references \"Blog\" ( id ), title varchar ( 255 ) not null , body varchar ( 10000 ) ); GraphQL Types Blog 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 type Blog { # globally unique identifier nodeId : ID ! id : Int ! name : String ! description : String blogPostCollection ( \"\"\"Query the first `n` records in the collection\"\"\" first : Int \"\"\"Query the last `n` records in the collection\"\"\" last : Int \"\"\"Query values in the collection before the provided cursor\"\"\" before : Cursor \"\"\"Query values in the collection after the provided cursor\"\"\" after : Cursor \"\"\"Filters to apply to the results set when querying from the collection\"\"\" filter : BlogPostFilter \"\"\"Sort order to apply to the collection\"\"\" orderBy : [ BlogPostOrderBy ! ] ): BlogPostConnection } Where blogPostCollection exposes the full Query interface to BlogPost s. Example Query Result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { blogCollection { edges { node { name blogPostCollection { edges { node { id title } } } } } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 { \"data\" : { \"blogCollection\" : { \"edges\" : [ { \"node\" : { \"name\" : \"pg_graphql blog\" , \"blogPostCollection\" : { \"edges\" : [ { \"node\" : { \"id\" : 2 , \"title\" : \"fIr3t p0sT\" } }, { \"node\" : { \"id\" : 3 , \"title\" : \"graphql with postgres\" } } ] } } } ] } } } Many-to-One A foreign key on table A referencing table B defines a many-to-one relationship from table B to table A. SQL Setup 1 2 3 4 5 6 7 8 9 10 11 create table \"Blog\" ( id serial primary key , name varchar ( 255 ) not null ); create table \"BlogPost\" ( id serial primary key , \"blogId\" integer not null references \"Blog\" ( id ), title varchar ( 255 ) not null , body varchar ( 10000 ) ); GraphQL Types BlogPost 1 2 3 4 5 6 7 8 9 type BlogPost { nodeId : ID ! id : Int ! blogId : Int ! title : String ! body : String blog : Blog } Where blog exposes the Blog record associated with the BlogPost . Query Result 1 2 3 4 5 6 7 8 9 10 11 12 { blogPostCollection { edges { node { title blog { name } } } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 { \"data\" : { \"blogPostCollection\" : { \"edges\" : [ { \"node\" : { \"blog\" : { \"name\" : \"pg_graphql blog\" }, \"title\" : \"fIr3t p0sT\" } }, { \"node\" : { \"blog\" : { \"name\" : \"pg_graphql blog\" }, \"title\" : \"graphql with postgres\" } } ] } } } One-to-One A one-to-one relationship is defined by a foreign key on table A referencing table B where the columns making up the foreign key on table A are unique. SQL Setup 1 2 3 4 5 6 7 8 9 10 create table \"EmailAddress\" ( id serial primary key , address text unique not null ); create table \"Employee\" ( id serial primary key , name text not null , email_address_id int unique references \"EmailAddress\" ( id ) ); GraphQL Types Employee Employee 1 2 3 4 5 6 7 type Employee { nodeId : ID ! id : Int ! name : String ! emailAddressId : Int emailAddress : EmailAddress } 1 2 3 4 5 6 type EmailAddress { nodeId : ID ! id : Int ! address : String ! employee : Employee } Example Query Result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { employeeCollection { edges { node { name emailAddress { address employee { name } } } } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { \"data\" : { \"employeeCollection\" : { \"edges\" : [ { \"node\" : { \"name\" : \"Foo Barington\" , \"emailAddress\" : { \"address\" : \"foo@bar.com\" , \"employee\" : { \"name\" : \"Foo Barington\" } } } } ] } } }","title":"API"},{"location":"api/#querytype","text":"The Query type is the entrypoint for all read access into the graph.","title":"QueryType"},{"location":"api/#node","text":"The node interface allows for retrieving records that are uniquely identifiable by a globally unique nodeId: ID! field. For more information about nodeId, see nodeId . SQL Setup 1 2 3 4 5 6 7 create table \"Blog\" ( id serial primary key , name varchar ( 255 ) not null , description varchar ( 255 ), \"createdAt\" timestamp not null , \"updatedAt\" timestamp not null ); GraphQL Types QueryType 1 2 3 4 5 6 7 \"\"\"The root type for querying data\"\"\" type Query { \"\"\"Retrieve a record by its `ID`\"\"\" node ( nodeId: ID !): Node } To query the node interface effectively, use inline fragments to specify which fields to return for each type. Example Query Response 1 2 3 4 5 6 7 8 9 10 11 12 { node ( nodeId: \"WyJwdWJsaWMiLCAiYmxvZyIsIDFd\" ) { nodeId # Inline fragment for `Blog` type ... on Blog { name description } } } 1 2 3 4 5 6 7 8 9 { \"data\" : { \"node\" : { \"name\" : \"Some Blog\" , \"nodeId\" : \"WyJwdWJsaWMiLCAiYmxvZyIsIDFd\" , \"description\" : \"Description of Some Blog\" } } }","title":"Node"},{"location":"api/#collections","text":"Each table has top level entry in the Query type for selecting records from that table. Collections return a connection type and can be paginated , filtered , and sorted using the available arguments. SQL Setup 1 2 3 4 5 6 7 create table \"Blog\" ( id serial primary key , name varchar ( 255 ) not null , description varchar ( 255 ), \"createdAt\" timestamp not null , \"updatedAt\" timestamp not null ); GraphQL Types QueryType 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \"\"\"The root type for querying data\"\"\" type Query { \"\"\"A pagable collection of type `Blog`\"\"\" blogCollection ( \"\"\"Query the first `n` records in the collection\"\"\" first: Int \"\"\"Query the last `n` records in the collection\"\"\" last: Int \"\"\"Query values in the collection before the provided cursor\"\"\" before: Cursor \"\"\"Query values in the collection after the provided cursor\"\"\" after: Cursor \"\"\"Filters to apply to the results set when querying from the collection\"\"\" filter: BlogFilter \"\"\"Sort order to apply to the collection\"\"\" orderBy: [ BlogOrderBy !] ): BlogConnection } Connection types are the primary interface to returning records from a collection. Connections wrap a result set with some additional metadata. BlogConnection BlogEdge PageInfo Blog BlogOrderBy BlogFilter 1 2 3 4 5 6 7 8 9 10 11 12 type BlogConnection { # Count of all records matching the *filter* criteria totalCount: Int ! # Pagination metadata pageInfo: PageInfo ! # Result set edges: [ BlogEdge !]! } 1 2 3 4 5 6 7 8 9 type BlogEdge { # Unique identifier of the record within the query cursor: String ! # Contents of a record/row in the results set node: Blog } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 type PageInfo { # unique identifier of the first record within the query startCursor: String # unique identifier of the last record within the query endCursor: String # is another page of content available hasNextPage: Boolean ! # is another page of content available hasPreviousPage: Boolean ! } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # A record from the `blog` table type Blog { # globally unique identifier nodeId: ID ! # Value from `id` column id: Int ! # Value from `name` column name: String ! # Value from `description` column description: String # Value from `createdAt` column createdAt: Datetime ! # Value from `updatedAt` column updatedAt: Datetime ! } 1 2 3 4 5 6 7 input BlogOrderBy { id: OrderByDirection name: OrderByDirection description: OrderByDirection createdAt: OrderByDirection updatedAt: OrderByDirection } 1 2 3 4 5 6 7 8 input BlogFilter { nodeId: IDFilter id: IntFilter name: StringFilter description: StringFilter createdAt: DatetimeFilter updatedAt: DatetimeFilter } Note The totalCount field is disabled by default because it can be expensive on large tables. To enable it use a comment directive","title":"Collections"},{"location":"api/#pagination","text":"Paginating forwards and backwards through collections is handled using the first , last , before , and after parameters, following the relay spec . QueryType 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 type Query { blogCollection ( \"\"\"Query the first `n` records in the collection\"\"\" first: Int \"\"\"Query the last `n` records in the collection\"\"\" last: Int \"\"\"Query values in the collection before the provided cursor\"\"\" before: Cursor \"\"\"Query values in the collection after the provided cursor\"\"\" after: Cursor ... truncated ... ): BlogConnection } Metadata relating to the current page of a result set is available on the pageInfo field of the connection type returned from a collection. PageInfo BlogConnection 1 2 3 4 5 6 7 8 9 10 11 12 13 14 type PageInfo { # unique identifier of the first record within the query startCursor: String # unique identifier of the last record within the query endCursor: String # is another page of content available hasNextPage: Boolean ! # is another page of content available hasPreviousPage: Boolean ! } 1 2 3 4 5 6 7 8 9 type BlogConnection { # Pagination metadata pageInfo: PageInfo ! # Result set edges: [ BlogEdge !]! } To paginate forward in the collection, use the first and after aguments. To retrive the first page, the after argument should be null or absent. Example Query Page 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { blogCollection ( first: 2 , after: null ) { pageInfo { startCursor endCursor hasPreviousPage hasNextPage } edges { cursor node { id } } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 { \"data\" : { \"blogCollection\" : { \"edges\" : [ { \"node\" : { \"id\" : 1 }, \"cursor\" : \"WzFd\" }, { \"node\" : { \"id\" : 2 }, \"cursor\" : \"WzJd\" } ], \"pageInfo\" : { \"startCursor\" : \"WzFd\" , \"endCursor\" : \"WzJd\" , \"hasNextPage\" : true , \"hasPreviousPage\" : false } } } } To retrieve the next page, provide the cursor value from data.blogCollection.pageInfo.endCursor to the after argument of another query. Query Page 2 1 2 3 4 5 6 7 { blogCollection ( first: 2 , after: \"WzJd\" ) { ... truncated ... } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 { \"data\" : { \"blogCollection\" : { \"edges\" : [ { \"node\" : { \"id\" : 3 }, \"cursor\" : \"WzNd\" }, { \"node\" : { \"id\" : 4 }, \"cursor\" : \"WzRd\" } ], \"pageInfo\" : { \"startCursor\" : \"WzNd\" , \"endCursor\" : \"WzRd\" , \"hasNextPage\" : false , \"hasPreviousPage\" : true } } } } once the collection has been fully enumerated, data.blogConnection.pageInfo.hasNextPage returns false. To paginate backwards through a collection, repeat the process substituting first -> last , after -> before , hasNextPage -> hasPreviousPage","title":"Pagination"},{"location":"api/#filtering","text":"To filter the result set, use the filter argument. QueryType 1 2 3 4 5 6 7 8 9 10 11 type Query { blogCollection ( \"\"\"Filters to apply to the results set when querying from the collection\"\"\" filter: BlogFilter ... truncated ... ): BlogConnection } Where the <Table>Filter type enumerates filterable fields and their associated <Type>Filter . BlogFilter IntFilter StringFilter 1 2 3 4 5 6 7 8 input BlogFilter { nodeId: IDFilter id: IntFilter name: StringFilter description: StringFilter createdAt: DatetimeFilter updatedAt: DatetimeFilter } 1 2 3 4 5 6 7 8 9 10 11 12 \"\"\" Boolean expression comparing fields on type \"Int\" \"\"\" input IntFilter { eq: Int gt: Int gte: Int in: [ Int !] lt: Int lte: Int neq: Int } 1 2 3 4 5 6 7 8 9 10 11 12 \"\"\" Boolean expression comparing fields on type \"String\" \"\"\" input StringFilter { eq: String gt: String gte: String in: [ String !] lt: String lte: String neq: String } The following list shows the operators that may be available on <Type>Filter types. Operator Description eq Equal To neq Not Equal To gt Greater Than gte Greater Than Or Equal To in Contained by Value List lt Less Than lte Less Than Or Equal To Not all operators are available on every <Type>Filter type. For example, UUIDFilter only supports eq and neq because UUID s are not ordered. Example Query Result 1 2 3 4 5 6 7 8 9 10 11 12 { blogCollection ( filter: { id: { lt: 3 }} , ) { edges { cursor node { id } } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 { \"data\" : { \"blogCollection\" : { \"edges\" : [ { \"node\" : { \"id\" : 1 }, \"cursor\" : \"WzFd\" }, { \"node\" : { \"id\" : 2 }, \"cursor\" : \"WzJd\" } ] } } } When multiple filters are provided to the filter argument, all conditions must be met for a record to be returned. In other words, multiple filters are composed with AND boolean logic. We expect to expand support to user defined AND and OR composition in a future release.","title":"Filtering"},{"location":"api/#ordering","text":"The default order of results is defined by the underlying table's primary key column/s in ascending order. That default can be overridden by passing an array of <Table>OrderBy to the collection's orderBy argument. QueryType BlogOrderBy OrderByDirection 1 2 3 4 5 6 7 8 9 10 11 type Query { blogCollection ( \"\"\"Sort order to apply to the collection\"\"\" orderBy: [ BlogOrderBy !] ... truncated ... ): BlogConnection } 1 2 3 4 5 6 7 input BlogOrderBy { id: OrderByDirection name: OrderByDirection description: OrderByDirection createdAt: OrderByDirection updatedAt: OrderByDirection } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \"\"\"Defines a per-field sorting order\"\"\" enum OrderByDirection { \"\"\"Ascending order, nulls first\"\"\" AscNullsFirst \"\"\"Ascending order, nulls last\"\"\" AscNullsLast \"\"\"Descending order, nulls first\"\"\" DescNullsFirst \"\"\"Descending order, nulls last\"\"\" DescNullsLast } Example Query Result 1 2 3 4 5 6 7 8 9 10 11 { blogCollection ( orderBy: [{ id: DescNullsLast }] ) { edges { node { id } } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 { \"data\" : { \"blogCollection\" : { \"edges\" : [ { \"node\" : { \"id\" : 4 } }, { \"node\" : { \"id\" : 3 } }, { \"node\" : { \"id\" : 2 } }, { \"node\" : { \"id\" : 1 } } ] } } } Note, only one key value pair may be provided to each element of the input array. For example, [{name: AscNullsLast}, {id: AscNullFirst}] is valid. Passing multiple key value pairs in a single element of the input array e.g. [{name: AscNullsLast, id: AscNullFirst}] , is invalid.","title":"Ordering"},{"location":"api/#mutationtype","text":"The Mutation type is the entrypoint for mutations/edits. Each table has top level entry in the Mutation type for inserting insertInto<Table>Collection , updating update<Table>Collection and deleting deleteFrom<Table>Collection . SQL Setup 1 2 3 4 5 6 7 create table \"Blog\" ( id serial primary key , name varchar ( 255 ) not null , description varchar ( 255 ), \"createdAt\" timestamp not null default now (), \"updatedAt\" timestamp ); MutationType 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 \"\"\"The root type for creating and mutating data\"\"\" type Mutation { \"\"\"Adds one or more `BlogInsertResponse` records to the collection\"\"\" insertIntoBlogCollection ( \"\"\"Records to add to the Blog collection\"\"\" objects: [ BlogInsertInput !]! ): BlogInsertResponse \"\"\"Updates zero or more records in the collection\"\"\" updateBlogCollection ( \"\"\" Fields that are set will be updated for all records matching the `filter` \"\"\" set: BlogUpdateInput ! \"\"\"Restricts the mutation's impact to records matching the critera\"\"\" filter: BlogFilter \"\"\" The maximum number of records in the collection permitted to be affected \"\"\" atMost: Int ! = 1 ): BlogUpdateResponse ! \"\"\"Deletes zero or more records from the collection\"\"\" deleteFromBlogCollection ( \"\"\"Restricts the mutation's impact to records matching the critera\"\"\" filter: BlogFilter \"\"\" The maximum number of records in the collection permitted to be affected \"\"\" atMost: Int ! = 1 ): BlogDeleteResponse ! }","title":"MutationType"},{"location":"api/#insert","text":"To add records to a collection, use the insertInto<Table>Collection field on the Mutation type. SQL Setup 1 2 3 4 5 6 7 create table \"Blog\" ( id serial primary key , name varchar ( 255 ) not null , description varchar ( 255 ), \"createdAt\" timestamp not null default now (), \"updatedAt\" timestamp ); GraphQL Types MutationType BlogInsertInput BlogInsertResponse 1 2 3 4 5 6 7 8 9 10 11 12 \"\"\"The root type for creating and mutating data\"\"\" type Mutation { \"\"\"Adds one or more `BlogInsertResponse` records to the collection\"\"\" insertIntoBlogCollection ( \"\"\"Records to add to the Blog collection\"\"\" objects: [ BlogInsertInput !]! ): BlogInsertResponse } 1 2 3 4 5 6 input BlogInsertInput { name: String description: String createdAt: Datetime updatedAt: Datetime } 1 2 3 4 5 6 7 type BlogInsertResponse { \"\"\"Count of the records impacted by the mutation\"\"\" affectedCount: Int ! \"\"\"Array of records impacted by the mutation\"\"\" records: [ Blog !]! } Where elements in the objects array are inserted into the underlying table. Example Query Result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 mutation { insertIntoBlogCollection ( objects: [ { name: \"foo\" } , { name: \"bar\" } , ] ) { affectedCount records { id name } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { \"data\" : { \"insertIntoBlogCollection\" : { \"records\" : [ { \"id\" : 1 , \"name\" : \"foo\" }, { \"id\" : 2 , \"name\" : \"bar\" } ], \"affectedCount\" : 2 } } }","title":"Insert"},{"location":"api/#update","text":"To update records in a collection, use the update<Table>Collection field on the Mutation type. SQL Setup 1 2 3 4 5 6 7 create table \"Blog\" ( id serial primary key , name varchar ( 255 ) not null , description varchar ( 255 ), \"createdAt\" timestamp not null default now (), \"updatedAt\" timestamp ); GraphQL Types MutationType BlogUpdateInput BlogUpdateResponse 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \"\"\"The root type for creating and mutating data\"\"\" type Mutation { \"\"\"Updates zero or more records in the collection\"\"\" updateBlogCollection ( \"\"\" Fields that are set will be updated for all records matching the `filter` \"\"\" set: BlogUpdateInput ! \"\"\"Restricts the mutation's impact to records matching the critera\"\"\" filter: BlogFilter \"\"\" The maximum number of records in the collection permitted to be affected \"\"\" atMost: Int ! = 1 ): BlogUpdateResponse ! } 1 2 3 4 5 6 input BlogUpdateInput { name: String description: String createdAt: Datetime updatedAt: Datetime } 1 2 3 4 5 6 7 8 9 type BlogUpdateResponse { \"\"\"Count of the records impacted by the mutation\"\"\" affectedCount: Int ! \"\"\"Array of records impacted by the mutation\"\"\" records: [ Blog !]! } Where the set argument is a key value pair describing the values to update, filter controls which records should be updated, and atMost restricts the maximum number of records that may be impacted. If the number of records impacted by the mutation exceeds the atMost parameter the operation will return an error. Example Query Result 1 2 3 4 5 6 7 8 9 10 11 12 mutation { updateBlogCollection ( set: { name: \"baz\" } filter: { id: { eq: 1 }} ) { affectedCount records { id name } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 { \"data\" : { \"updateBlogCollection\" : { \"records\" : [ { \"id\" : 1 , \"name\" : \"baz\" } ], \"affectedCount\" : 1 } } }","title":"Update"},{"location":"api/#delete","text":"To remove records from a collection, use the deleteFrom<Table>Collection field on the Mutation type. SQL Setup 1 2 3 4 5 6 7 create table \"Blog\" ( id serial primary key , name varchar ( 255 ) not null , description varchar ( 255 ), \"createdAt\" timestamp not null default now (), \"updatedAt\" timestamp ); GraphQL Types MutationType BlogFilter BlogDeleteResponse 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \"\"\"The root type for creating and mutating data\"\"\" type Mutation { \"\"\"Deletes zero or more records from the collection\"\"\" deleteFromBlogCollection ( \"\"\"Restricts the mutation's impact to records matching the critera\"\"\" filter: BlogFilter \"\"\" The maximum number of records in the collection permitted to be affected \"\"\" atMost: Int ! = 1 ): BlogDeleteResponse ! } 1 2 3 4 5 6 7 input BlogFilter { id: IntFilter name: StringFilter description: StringFilter createdAt: DatetimeFilter updatedAt: DatetimeFilter } 1 2 3 4 5 6 7 type BlogDeleteResponse { \"\"\"Count of the records impacted by the mutation\"\"\" affectedCount: Int ! \"\"\"Array of records impacted by the mutation\"\"\" records: [ Blog !]! } Where filter controls which records should be deleted and atMost restricts the maximum number of records that may be deleted. If the number of records impacted by the mutation exceeds the atMost parameter the operation will return an error. Example Query Result 1 2 3 4 5 6 7 8 9 10 11 mutation { deleteFromBlogCollection ( filter: { id: { eq: 1 }} ) { affectedCount records { id name } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 { \"data\" : { \"deleteFromBlogCollection\" : { \"records\" : [ { \"id\" : 1 , \"name\" : \"baz\" } ], \"affectedCount\" : 1 } } }","title":"Delete"},{"location":"api/#concepts","text":"","title":"Concepts"},{"location":"api/#nodeid","text":"The base GraphQL type for every table with a primary key is automatically assigned a nodeId: ID! field. That value, can be passed to the node entrypoint of the Query type to retrieve its other fields. nodeId may also be used as a caching key. relay support By default relay expects the ID field for types to have the name id . pg_graphql uses nodeId by default to avoid conflicting with user defined id columns. You can configure relay to work with pg_graphql's nodeId field with relay's nodeInterfaceIdField option. More info available here . SQL Setup 1 2 3 4 create table \"Blog\" ( id serial primary key , name varchar ( 255 ) not null ); GraphQL Types Blog 1 2 3 4 5 type Blog { nodeId : ID ! # this field id : Int ! name : String ! }","title":"nodeId"},{"location":"api/#relationships","text":"Relationships between collections in the Graph are derived from foreign keys.","title":"Relationships"},{"location":"api/#one-to-many","text":"A foreign key on table A referencing table B defines a one-to-many relationship from table A to table B. SQL Setup 1 2 3 4 5 6 7 8 9 10 11 create table \"Blog\" ( id serial primary key , name varchar ( 255 ) not null ); create table \"BlogPost\" ( id serial primary key , \"blogId\" integer not null references \"Blog\" ( id ), title varchar ( 255 ) not null , body varchar ( 10000 ) ); GraphQL Types Blog 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 type Blog { # globally unique identifier nodeId : ID ! id : Int ! name : String ! description : String blogPostCollection ( \"\"\"Query the first `n` records in the collection\"\"\" first : Int \"\"\"Query the last `n` records in the collection\"\"\" last : Int \"\"\"Query values in the collection before the provided cursor\"\"\" before : Cursor \"\"\"Query values in the collection after the provided cursor\"\"\" after : Cursor \"\"\"Filters to apply to the results set when querying from the collection\"\"\" filter : BlogPostFilter \"\"\"Sort order to apply to the collection\"\"\" orderBy : [ BlogPostOrderBy ! ] ): BlogPostConnection } Where blogPostCollection exposes the full Query interface to BlogPost s. Example Query Result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { blogCollection { edges { node { name blogPostCollection { edges { node { id title } } } } } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 { \"data\" : { \"blogCollection\" : { \"edges\" : [ { \"node\" : { \"name\" : \"pg_graphql blog\" , \"blogPostCollection\" : { \"edges\" : [ { \"node\" : { \"id\" : 2 , \"title\" : \"fIr3t p0sT\" } }, { \"node\" : { \"id\" : 3 , \"title\" : \"graphql with postgres\" } } ] } } } ] } } }","title":"One-to-Many"},{"location":"api/#many-to-one","text":"A foreign key on table A referencing table B defines a many-to-one relationship from table B to table A. SQL Setup 1 2 3 4 5 6 7 8 9 10 11 create table \"Blog\" ( id serial primary key , name varchar ( 255 ) not null ); create table \"BlogPost\" ( id serial primary key , \"blogId\" integer not null references \"Blog\" ( id ), title varchar ( 255 ) not null , body varchar ( 10000 ) ); GraphQL Types BlogPost 1 2 3 4 5 6 7 8 9 type BlogPost { nodeId : ID ! id : Int ! blogId : Int ! title : String ! body : String blog : Blog } Where blog exposes the Blog record associated with the BlogPost . Query Result 1 2 3 4 5 6 7 8 9 10 11 12 { blogPostCollection { edges { node { title blog { name } } } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 { \"data\" : { \"blogPostCollection\" : { \"edges\" : [ { \"node\" : { \"blog\" : { \"name\" : \"pg_graphql blog\" }, \"title\" : \"fIr3t p0sT\" } }, { \"node\" : { \"blog\" : { \"name\" : \"pg_graphql blog\" }, \"title\" : \"graphql with postgres\" } } ] } } }","title":"Many-to-One"},{"location":"api/#one-to-one","text":"A one-to-one relationship is defined by a foreign key on table A referencing table B where the columns making up the foreign key on table A are unique. SQL Setup 1 2 3 4 5 6 7 8 9 10 create table \"EmailAddress\" ( id serial primary key , address text unique not null ); create table \"Employee\" ( id serial primary key , name text not null , email_address_id int unique references \"EmailAddress\" ( id ) ); GraphQL Types Employee Employee 1 2 3 4 5 6 7 type Employee { nodeId : ID ! id : Int ! name : String ! emailAddressId : Int emailAddress : EmailAddress } 1 2 3 4 5 6 type EmailAddress { nodeId : ID ! id : Int ! address : String ! employee : Employee } Example Query Result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { employeeCollection { edges { node { name emailAddress { address employee { name } } } } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { \"data\" : { \"employeeCollection\" : { \"edges\" : [ { \"node\" : { \"name\" : \"Foo Barington\" , \"emailAddress\" : { \"address\" : \"foo@bar.com\" , \"employee\" : { \"name\" : \"Foo Barington\" } } } } ] } } }","title":"One-to-One"},{"location":"computed_fields/","text":"PostgreSQL Builtin (Preferred) PostgreSQL has a builtin method for adding generated columns to tables. Generated columns are reflected identically to non-generated columns. This is the recommended approach to adding computed fields when your computation meets the restrictions. Namely: expression must be immutable expression may only reference the current row For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 begin ; comment on schema public is '@graphql({\"inflect_names\": true})' ; create table public . account ( id serial primary key , first_name varchar ( 255 ) not null , last_name varchar ( 255 ) not null , -- Computed Column full_name text generated always as ( first_name || ' ' || last_name ) stored ); insert into public . account ( first_name , last_name ) values ( 'Foo' , 'Fooington' ); select jsonb_pretty ( graphql . resolve ( $$ { accountCollection { edges { node { id firstName lastName fullName } } } } $$ ) ); jsonb_pretty ------------------------------------------------------ { + \"data\" : { + \"accountCollection\" : { + \"edges\" : [ + { + \"node\" : { + \"id\" : 1 , + \"fullName\" : \"Foo Fooington\" , + \"lastName\" : \"Fooington\" , + \"firstName\" : \"Foo\" + } + } + ] + } + } + } ( 1 row ) rollback ; Extending Types with Functions For arbitrary computations that do not meet the requirements for generated columns , a table's reflected GraphQL type can be extended by creating a function that: accepts a single parameter of the table's tuple type has a name starting with an underscore 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 begin ; comment on schema public is '@graphql({\"inflect_names\": true})' ; create table public . account ( id serial primary key , first_name varchar ( 255 ) not null , last_name varchar ( 255 ) not null , parent_id int references account ( id ) ); -- Extend with function create function public . _full_name ( rec public . account ) returns text immutable strict language sql as $$ select format ( '%s %s' , rec . first_name , rec . last_name ) $$ ; insert into public . account ( first_name , last_name , parent_id ) values ( 'Foo' , 'Fooington' , 1 ); select jsonb_pretty ( graphql . resolve ( $$ { accountCollection { edges { node { id firstName lastName fullName parent { fullName } } } } } $$ ) ); jsonb_pretty --------------------------------------------------------- { + \"data\" : { + \"accountCollection\" : { + \"edges\" : [ + { + \"node\" : { + \"id\" : 1 , + \"parent\" : { + \"fullName\" : \"Foo Fooington\" + } , + \"fullName\" : \"Foo Fooington\" , + \"lastName\" : \"Fooington\" , + \"firstName\" : \"Foo\" + } + } + ] + } + } + } ( 1 row ) rollback ;","title":"Computed Fields"},{"location":"computed_fields/#postgresql-builtin-preferred","text":"PostgreSQL has a builtin method for adding generated columns to tables. Generated columns are reflected identically to non-generated columns. This is the recommended approach to adding computed fields when your computation meets the restrictions. Namely: expression must be immutable expression may only reference the current row For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 begin ; comment on schema public is '@graphql({\"inflect_names\": true})' ; create table public . account ( id serial primary key , first_name varchar ( 255 ) not null , last_name varchar ( 255 ) not null , -- Computed Column full_name text generated always as ( first_name || ' ' || last_name ) stored ); insert into public . account ( first_name , last_name ) values ( 'Foo' , 'Fooington' ); select jsonb_pretty ( graphql . resolve ( $$ { accountCollection { edges { node { id firstName lastName fullName } } } } $$ ) ); jsonb_pretty ------------------------------------------------------ { + \"data\" : { + \"accountCollection\" : { + \"edges\" : [ + { + \"node\" : { + \"id\" : 1 , + \"fullName\" : \"Foo Fooington\" , + \"lastName\" : \"Fooington\" , + \"firstName\" : \"Foo\" + } + } + ] + } + } + } ( 1 row ) rollback ;","title":"PostgreSQL Builtin (Preferred)"},{"location":"computed_fields/#extending-types-with-functions","text":"For arbitrary computations that do not meet the requirements for generated columns , a table's reflected GraphQL type can be extended by creating a function that: accepts a single parameter of the table's tuple type has a name starting with an underscore 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 begin ; comment on schema public is '@graphql({\"inflect_names\": true})' ; create table public . account ( id serial primary key , first_name varchar ( 255 ) not null , last_name varchar ( 255 ) not null , parent_id int references account ( id ) ); -- Extend with function create function public . _full_name ( rec public . account ) returns text immutable strict language sql as $$ select format ( '%s %s' , rec . first_name , rec . last_name ) $$ ; insert into public . account ( first_name , last_name , parent_id ) values ( 'Foo' , 'Fooington' , 1 ); select jsonb_pretty ( graphql . resolve ( $$ { accountCollection { edges { node { id firstName lastName fullName parent { fullName } } } } } $$ ) ); jsonb_pretty --------------------------------------------------------- { + \"data\" : { + \"accountCollection\" : { + \"edges\" : [ + { + \"node\" : { + \"id\" : 1 , + \"parent\" : { + \"fullName\" : \"Foo Fooington\" + } , + \"fullName\" : \"Foo Fooington\" , + \"lastName\" : \"Fooington\" , + \"firstName\" : \"Foo\" + } + } + ] + } + } + } ( 1 row ) rollback ;","title":"Extending Types with Functions"},{"location":"configuration/","text":"Extra configuration options can be set on SQL entities using comment directives. Comment Directives Comment directives are snippets of configuration associated with SQL entities that alter how those entities behave. The format of a comment directive is 1 @ graphql ( < JSON > ) Inflection Inflection describes how SQL entities' names are transformed into GraphQL type and field names. By default, inflection is disabled and SQL names are literally interpolated such that 1 2 3 4 create table \"BlogPost\" ( id int primary key , ... ); results in GraphQL type names like 1 2 3 4 BlogPost BlogPostEdge BlogPostConnection ... Since snake case is a common casing structure for SQL types, pg_graphql support basic inflection from snake_case to PascalCase for type names, and snake_case to camelCase for field names to match Javascript conventions. The inflection directive can be applied at the schema level with: 1 comment on schema < schema_name > is e '@graphql({\"inflect_names\": true})' ; for example 1 2 3 4 5 6 comment on schema public is e '@graphql({\"inflect_names\": true})' ; create table blog_post ( id int primary key , ... ); similarly would generated the GraphQL type names 1 2 3 4 BlogPost BlogPostEdge BlogPostConnection ... For more fine grained adjustments to reflected names, see renaming . totalCount totalCount is an opt-in field that extends a table's Connection type. It provides a count of the rows that match the query's filters, and ignores pagination arguments. 1 2 3 4 5 6 7 type BlogPostConnection { edges: [ BlogPostEdge !]! pageInfo: PageInfo ! \"\"\"The total number of records matching the `filter` criteria\"\"\" totalCount: Int ! # this field } to enable totalCount for a table, use the directive 1 comment on table \"BlogPost\" is e '@graphql({\"totalCount\": {\"enabled\": true}})' ; for example 1 2 3 4 5 create table \"BlogPost\" ( id serial primary key , email varchar ( 255 ) not null ); comment on table \"BlogPost\" is e '@graphql({\"totalCount\": {\"enabled\": true}})' ; Renaming Table's Type Use the \"name\" JSON key to override a table's type name. 1 2 3 4 5 6 create table account ( id serial primary key ); comment on table public . account is e '@graphql({\"name\": \"AccountHolder\"})' ; results in: 1 2 3 type AccountHolder { # previously: \"Account\" id: Int ! } Column's Field Name Use the \"name\" JSON key to override a column's field name. 1 2 3 4 5 6 7 create table public . \"Account\" ( id serial primary key , email text ); comment on column \"Account\" . email is e '@graphql({\"name\": \"emailAddress\"})' ; results in: 1 2 3 4 5 type Account { nodeId: ID ! id: Int ! emailAddress: String ! # previously \"email\" } Computed Field Use the \"name\" JSON key to override a computed field's name. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 create table \"Account\" ( id serial primary key , \"firstName\" varchar ( 255 ) not null , \"lastName\" varchar ( 255 ) not null ); -- Extend with function create function public . \"_fullName\" ( rec public . \"Account\" ) returns text immutable strict language sql as $$ select format ( '%s %s' , rec . \"firstName\" , rec . \"lastName\" ) $$ ; comment on function public . _full_name is e '@graphql({\"name\": \"displayName\"})' ; results in: 1 2 3 4 5 6 7 type Account { nodeId: ID ! id: Int ! firstName: String ! lastName: String ! displayName: String # previously \"fullName\" } Relationship's Field Use the \"local_name\" and \"foreign_name\" JSON keys to override a a relationships inbound and outbound field names. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 create table \"Account\" ( id serial primary key ); create table \"Post\" ( id serial primary key , \"accountId\" integer not null references \"Account\" ( id ), title text not null , body text ); comment on constraint post_owner_id_fkey on post is E '@graphql({\"foreign_name\": \"author\", \"local_name\": \"posts\"})' ; results in: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 type Post { nodeId: ID ! id: Int ! accountId: Int ! title: String ! body: String ! author: Account # was \"account\" } type Account { id: Int ! posts ( # was \"postCollection\" after: Cursor , before: Cursor , filter: PostFilter , first: Int , last: Int , orderBy: [ PostOrderBy !] ): PostConnection }","title":"Configuration"},{"location":"configuration/#comment-directives","text":"Comment directives are snippets of configuration associated with SQL entities that alter how those entities behave. The format of a comment directive is 1 @ graphql ( < JSON > )","title":"Comment Directives"},{"location":"configuration/#inflection","text":"Inflection describes how SQL entities' names are transformed into GraphQL type and field names. By default, inflection is disabled and SQL names are literally interpolated such that 1 2 3 4 create table \"BlogPost\" ( id int primary key , ... ); results in GraphQL type names like 1 2 3 4 BlogPost BlogPostEdge BlogPostConnection ... Since snake case is a common casing structure for SQL types, pg_graphql support basic inflection from snake_case to PascalCase for type names, and snake_case to camelCase for field names to match Javascript conventions. The inflection directive can be applied at the schema level with: 1 comment on schema < schema_name > is e '@graphql({\"inflect_names\": true})' ; for example 1 2 3 4 5 6 comment on schema public is e '@graphql({\"inflect_names\": true})' ; create table blog_post ( id int primary key , ... ); similarly would generated the GraphQL type names 1 2 3 4 BlogPost BlogPostEdge BlogPostConnection ... For more fine grained adjustments to reflected names, see renaming .","title":"Inflection"},{"location":"configuration/#totalcount","text":"totalCount is an opt-in field that extends a table's Connection type. It provides a count of the rows that match the query's filters, and ignores pagination arguments. 1 2 3 4 5 6 7 type BlogPostConnection { edges: [ BlogPostEdge !]! pageInfo: PageInfo ! \"\"\"The total number of records matching the `filter` criteria\"\"\" totalCount: Int ! # this field } to enable totalCount for a table, use the directive 1 comment on table \"BlogPost\" is e '@graphql({\"totalCount\": {\"enabled\": true}})' ; for example 1 2 3 4 5 create table \"BlogPost\" ( id serial primary key , email varchar ( 255 ) not null ); comment on table \"BlogPost\" is e '@graphql({\"totalCount\": {\"enabled\": true}})' ;","title":"totalCount"},{"location":"configuration/#renaming","text":"","title":"Renaming"},{"location":"configuration/#tables-type","text":"Use the \"name\" JSON key to override a table's type name. 1 2 3 4 5 6 create table account ( id serial primary key ); comment on table public . account is e '@graphql({\"name\": \"AccountHolder\"})' ; results in: 1 2 3 type AccountHolder { # previously: \"Account\" id: Int ! }","title":"Table's Type"},{"location":"configuration/#columns-field-name","text":"Use the \"name\" JSON key to override a column's field name. 1 2 3 4 5 6 7 create table public . \"Account\" ( id serial primary key , email text ); comment on column \"Account\" . email is e '@graphql({\"name\": \"emailAddress\"})' ; results in: 1 2 3 4 5 type Account { nodeId: ID ! id: Int ! emailAddress: String ! # previously \"email\" }","title":"Column's Field Name"},{"location":"configuration/#computed-field","text":"Use the \"name\" JSON key to override a computed field's name. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 create table \"Account\" ( id serial primary key , \"firstName\" varchar ( 255 ) not null , \"lastName\" varchar ( 255 ) not null ); -- Extend with function create function public . \"_fullName\" ( rec public . \"Account\" ) returns text immutable strict language sql as $$ select format ( '%s %s' , rec . \"firstName\" , rec . \"lastName\" ) $$ ; comment on function public . _full_name is e '@graphql({\"name\": \"displayName\"})' ; results in: 1 2 3 4 5 6 7 type Account { nodeId: ID ! id: Int ! firstName: String ! lastName: String ! displayName: String # previously \"fullName\" }","title":"Computed Field"},{"location":"configuration/#relationships-field","text":"Use the \"local_name\" and \"foreign_name\" JSON keys to override a a relationships inbound and outbound field names. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 create table \"Account\" ( id serial primary key ); create table \"Post\" ( id serial primary key , \"accountId\" integer not null references \"Account\" ( id ), title text not null , body text ); comment on constraint post_owner_id_fkey on post is E '@graphql({\"foreign_name\": \"author\", \"local_name\": \"posts\"})' ; results in: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 type Post { nodeId: ID ! id: Int ! accountId: Int ! title: String ! body: String ! author: Account # was \"account\" } type Account { id: Int ! posts ( # was \"postCollection\" after: Cursor , before: Cursor , filter: PostFilter , first: Int , last: Int , orderBy: [ PostOrderBy !] ): PostConnection }","title":"Relationship's Field"},{"location":"contributing/","text":"pg_graphql is OSS. PR and issues are welcome. Development Requirements: rust cargo pgx Testing Tests are located in ./test/sql with expected output in ./test/expected To run tests locally, execute: 1 $ cargo pgx install ; ./bin/installcheck Interactive PSQL Development To reduce the iteration cycle, you may want to launch a psql prompt with pg_graphql installed to experiment 1 cargo pgx run pg14 Try out the commands below to spin up a database with the extension installed & query a table using GraphQL. Experiment with aliasing field/table names and filtering on different columns. 1 2 3 4 5 6 7 8 graphqldb = create extension pg_graphql cascade ; CREATE EXTENSION graphqldb = create table book ( id int primary key , title text ); CREATE TABLE graphqldb = insert into book ( id , title ) values ( 1 , 'book 1' ); INSERT 0 1 Finally, execute some graphql queries against the table. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 graphqldb = select graphql . resolve ( $$ query { bookCollection { edges { node { id } } } } $$ ); resolve ---------------------------------------------------------------------- { \"data\" : { \"bookCollection\" : { \"edges\" : [ { \"node\" : { \"id\" : 1 }} ] }} , \"errors\" : [] } Documentation All public API must be documented. Building documentation requires python 3.6+ Install Dependencies Install mkdocs, themes, and extensions. 1 pip install -r docs/requirements_docs.txt Serving To serve the documentation locally run 1 mkdocs serve and visit the docs at http://127.0.0.1:8000/pg_graphql/","title":"Contributing"},{"location":"contributing/#development","text":"Requirements: rust cargo pgx","title":"Development"},{"location":"contributing/#testing","text":"Tests are located in ./test/sql with expected output in ./test/expected To run tests locally, execute: 1 $ cargo pgx install ; ./bin/installcheck","title":"Testing"},{"location":"contributing/#interactive-psql-development","text":"To reduce the iteration cycle, you may want to launch a psql prompt with pg_graphql installed to experiment 1 cargo pgx run pg14 Try out the commands below to spin up a database with the extension installed & query a table using GraphQL. Experiment with aliasing field/table names and filtering on different columns. 1 2 3 4 5 6 7 8 graphqldb = create extension pg_graphql cascade ; CREATE EXTENSION graphqldb = create table book ( id int primary key , title text ); CREATE TABLE graphqldb = insert into book ( id , title ) values ( 1 , 'book 1' ); INSERT 0 1 Finally, execute some graphql queries against the table. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 graphqldb = select graphql . resolve ( $$ query { bookCollection { edges { node { id } } } } $$ ); resolve ---------------------------------------------------------------------- { \"data\" : { \"bookCollection\" : { \"edges\" : [ { \"node\" : { \"id\" : 1 }} ] }} , \"errors\" : [] }","title":"Interactive PSQL Development"},{"location":"contributing/#documentation","text":"All public API must be documented. Building documentation requires python 3.6+","title":"Documentation"},{"location":"contributing/#install-dependencies","text":"Install mkdocs, themes, and extensions. 1 pip install -r docs/requirements_docs.txt","title":"Install Dependencies"},{"location":"contributing/#serving","text":"To serve the documentation locally run 1 mkdocs serve and visit the docs at http://127.0.0.1:8000/pg_graphql/","title":"Serving"},{"location":"example_schema/","text":"The following is a complete example showing how a sample SQL schema translates into a GraphQL schema. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 -- Turn on automatic inflection of type names comment on schema public is '@graphql({\"inflect_names\": true})' ; create table account ( id serial primary key , email varchar ( 255 ) not null , created_at timestamp not null , updated_at timestamp not null ); -- enable a `totalCount` field on the `account` query type comment on table account is e '@graphql({\"totalCount\": {\"enabled\": true}})' ; create table blog ( id serial primary key , owner_id integer not null references account ( id ), name varchar ( 255 ) not null , description varchar ( 255 ), created_at timestamp not null , updated_at timestamp not null ); create type blog_post_status as enum ( 'PENDING' , 'RELEASED' ); create table blog_post ( id uuid not null default uuid_generate_v4 () primary key , blog_id integer not null references blog ( id ), title varchar ( 255 ) not null , body varchar ( 10000 ), status blog_post_status not null , created_at timestamp not null , updated_at timestamp not null ); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 type Account implements Node { \"\"\"Globally Unique Record Identifier\"\"\" nodeId: ID ! id: Int ! email: String ! createdAt: Datetime ! blogCollection ( \"\"\"Query the first `n` records in the collection\"\"\" first: Int \"\"\"Query the last `n` records in the collection\"\"\" last: Int \"\"\"Query values in the collection before the provided cursor\"\"\" before: Cursor \"\"\"Query values in the collection after the provided cursor\"\"\" after: Cursor \"\"\"Filters to apply to the results set when querying from the collection\"\"\" filter: BlogFilter \"\"\"Sort order to apply to the collection\"\"\" orderBy: [ BlogOrderBy !] ): BlogConnection } type AccountConnection { edges: [ AccountEdge !]! pageInfo: PageInfo ! } type AccountDeleteResponse { \"\"\"Count of the records impacted by the mutation\"\"\" affectedCount: Int ! \"\"\"Array of records impacted by the mutation\"\"\" records: [ Account !]! } type AccountEdge { cursor: String ! node: Account ! } input AccountFilter { nodeId: IDFilter id: IntFilter email: StringFilter createdAt: DatetimeFilter } input AccountInsertInput { email: String createdAt: Datetime } type AccountInsertResponse { \"\"\"Count of the records impacted by the mutation\"\"\" affectedCount: Int ! \"\"\"Array of records impacted by the mutation\"\"\" records: [ Account !]! } input AccountOrderBy { id: OrderByDirection email: OrderByDirection createdAt: OrderByDirection } input AccountUpdateInput { email: String createdAt: Datetime } type AccountUpdateResponse { \"\"\"Count of the records impacted by the mutation\"\"\" affectedCount: Int ! \"\"\"Array of records impacted by the mutation\"\"\" records: [ Account !]! } type Blog implements Node { \"\"\"Globally Unique Record Identifier\"\"\" nodeId: ID ! id: Int ! ownerId: Int ! name: String ! description: String createdAt: Datetime ! owner: Account blogPostCollection ( \"\"\"Query the first `n` records in the collection\"\"\" first: Int \"\"\"Query the last `n` records in the collection\"\"\" last: Int \"\"\"Query values in the collection before the provided cursor\"\"\" before: Cursor \"\"\"Query values in the collection after the provided cursor\"\"\" after: Cursor \"\"\"Filters to apply to the results set when querying from the collection\"\"\" filter: BlogPostFilter \"\"\"Sort order to apply to the collection\"\"\" orderBy: [ BlogPostOrderBy !] ): BlogPostConnection } type BlogConnection { edges: [ BlogEdge !]! pageInfo: PageInfo ! } type BlogDeleteResponse { \"\"\"Count of the records impacted by the mutation\"\"\" affectedCount: Int ! \"\"\"Array of records impacted by the mutation\"\"\" records: [ Blog !]! } type BlogEdge { cursor: String ! node: Blog ! } input BlogFilter { nodeId: IDFilter id: IntFilter ownerId: IntFilter name: StringFilter description: StringFilter createdAt: DatetimeFilter } input BlogInsertInput { ownerId: Int name: String description: String createdAt: Datetime } type BlogInsertResponse { \"\"\"Count of the records impacted by the mutation\"\"\" affectedCount: Int ! \"\"\"Array of records impacted by the mutation\"\"\" records: [ Blog !]! } input BlogOrderBy { id: OrderByDirection ownerId: OrderByDirection name: OrderByDirection description: OrderByDirection createdAt: OrderByDirection } type BlogPost implements Node { \"\"\"Globally Unique Record Identifier\"\"\" nodeId: ID ! id: UUID ! blogId: Int ! title: String ! body: String status: BlogPostStatus ! createdAt: Datetime ! blog: Blog } type BlogPostConnection { edges: [ BlogPostEdge !]! pageInfo: PageInfo ! } type BlogPostDeleteResponse { \"\"\"Count of the records impacted by the mutation\"\"\" affectedCount: Int ! \"\"\"Array of records impacted by the mutation\"\"\" records: [ BlogPost !]! } type BlogPostEdge { cursor: String ! node: BlogPost ! } input BlogPostFilter { nodeId: IDFilter id: UUIDFilter blogId: IntFilter title: StringFilter body: StringFilter status: BlogPostStatusFilter createdAt: DatetimeFilter } input BlogPostInsertInput { id: UUID blogId: Int title: String body: String status: BlogPostStatus createdAt: Datetime } type BlogPostInsertResponse { \"\"\"Count of the records impacted by the mutation\"\"\" affectedCount: Int ! \"\"\"Array of records impacted by the mutation\"\"\" records: [ BlogPost !]! } input BlogPostOrderBy { id: OrderByDirection blogId: OrderByDirection title: OrderByDirection body: OrderByDirection status: OrderByDirection createdAt: OrderByDirection } enum BlogPostStatus { PENDING RELEASED } \"\"\" Boolean expression comparing fields on type \"BlogPostStatus\" \"\"\" input BlogPostStatusFilter { eq: BlogPostStatus in: [ BlogPostStatus !] neq: BlogPostStatus } input BlogPostUpdateInput { id: UUID blogId: Int title: String body: String status: BlogPostStatus createdAt: Datetime } type BlogPostUpdateResponse { \"\"\"Count of the records impacted by the mutation\"\"\" affectedCount: Int ! \"\"\"Array of records impacted by the mutation\"\"\" records: [ BlogPost !]! } input BlogUpdateInput { ownerId: Int name: String description: String createdAt: Datetime } type BlogUpdateResponse { \"\"\"Count of the records impacted by the mutation\"\"\" affectedCount: Int ! \"\"\"Array of records impacted by the mutation\"\"\" records: [ Blog !]! } \"\"\" Boolean expression comparing fields on type \"ID\" \"\"\" input IDFilter { eq: ID } scalar BigInt \"\"\" Boolean expression comparing fields on type \"BigInt\" \"\"\" input BigIntFilter { eq: BigInt gt: BigInt gte: BigInt in: [ BigInt !] lt: BigInt lte: BigInt neq: BigInt } \"\"\" Boolean expression comparing fields on type \"Boolean\" \"\"\" input BooleanFilter { eq: Boolean gt: Boolean gte: Boolean in: [ Boolean !] lt: Boolean lte: Boolean neq: Boolean } scalar Cursor scalar Date \"\"\" Boolean expression comparing fields on type \"Date\" \"\"\" input DateFilter { eq: Date gt: Date gte: Date in: [ Date !] lt: Date lte: Date neq: Date } scalar Datetime \"\"\" Boolean expression comparing fields on type \"Datetime\" \"\"\" input DatetimeFilter { eq: Datetime gt: Datetime gte: Datetime in: [ Datetime !] lt: Datetime lte: Datetime neq: Datetime } \"\"\" Boolean expression comparing fields on type \"Float\" \"\"\" input FloatFilter { eq: Float gt: Float gte: Float in: [ Float !] lt: Float lte: Float neq: Float } \"\"\" Boolean expression comparing fields on type \"Int\" \"\"\" input IntFilter { eq: Int gt: Int gte: Int in: [ Int !] lt: Int lte: Int neq: Int } scalar JSON \"\"\"The root type for creating and mutating data\"\"\" type Mutation { \"\"\"Deletes zero or more records from the `Account` collection\"\"\" deleteFromAccountCollection ( \"\"\"Restricts the mutation's impact to records matching the criteria\"\"\" filter: AccountFilter \"\"\" The maximum number of records in the collection permitted to be affected \"\"\" atMost: Int ! = 1 ): AccountDeleteResponse ! \"\"\"Deletes zero or more records from the `Blog` collection\"\"\" deleteFromBlogCollection ( \"\"\"Restricts the mutation's impact to records matching the criteria\"\"\" filter: BlogFilter \"\"\" The maximum number of records in the collection permitted to be affected \"\"\" atMost: Int ! = 1 ): BlogDeleteResponse ! \"\"\"Deletes zero or more records from the `BlogPost` collection\"\"\" deleteFromBlogPostCollection ( \"\"\"Restricts the mutation's impact to records matching the criteria\"\"\" filter: BlogPostFilter \"\"\" The maximum number of records in the collection permitted to be affected \"\"\" atMost: Int ! = 1 ): BlogPostDeleteResponse ! \"\"\"Adds one or more `Account` records to the collection\"\"\" insertIntoAccountCollection ( objects: [ AccountInsertInput !]!): AccountInsertResponse \"\"\"Adds one or more `Blog` records to the collection\"\"\" insertIntoBlogCollection ( objects: [ BlogInsertInput !]!): BlogInsertResponse \"\"\"Adds one or more `BlogPost` records to the collection\"\"\" insertIntoBlogPostCollection ( objects: [ BlogPostInsertInput !]!): BlogPostInsertResponse \"\"\"Updates zero or more records in the `Account` collection\"\"\" updateAccountCollection ( \"\"\" Fields that are set will be updated for all records matching the `filter` \"\"\" set: AccountUpdateInput ! \"\"\"Restricts the mutation's impact to records matching the criteria\"\"\" filter: AccountFilter \"\"\" The maximum number of records in the collection permitted to be affected \"\"\" atMost: Int ! = 1 ): AccountUpdateResponse ! \"\"\"Updates zero or more records in the `Blog` collection\"\"\" updateBlogCollection ( \"\"\" Fields that are set will be updated for all records matching the `filter` \"\"\" set: BlogUpdateInput ! \"\"\"Restricts the mutation's impact to records matching the criteria\"\"\" filter: BlogFilter \"\"\" The maximum number of records in the collection permitted to be affected \"\"\" atMost: Int ! = 1 ): BlogUpdateResponse ! \"\"\"Updates zero or more records in the `BlogPost` collection\"\"\" updateBlogPostCollection ( \"\"\" Fields that are set will be updated for all records matching the `filter` \"\"\" set: BlogPostUpdateInput ! \"\"\"Restricts the mutation's impact to records matching the criteria\"\"\" filter: BlogPostFilter \"\"\" The maximum number of records in the collection permitted to be affected \"\"\" atMost: Int ! = 1 ): BlogPostUpdateResponse ! } interface Node { \"\"\"Retrieves a record by `ID`\"\"\" nodeId: ID ! } \"\"\"Defines a per-field sorting order\"\"\" enum OrderByDirection { \"\"\"Ascending order, nulls first\"\"\" AscNullsFirst \"\"\"Ascending order, nulls last\"\"\" AscNullsLast \"\"\"Descending order, nulls first\"\"\" DescNullsFirst \"\"\"Descending order, nulls last\"\"\" DescNullsLast } type PageInfo { endCursor: String hasNextPage: Boolean ! hasPreviousPage: Boolean ! startCursor: String } \"\"\"The root type for querying data\"\"\" type Query { \"\"\"A pagable collection of type `Account`\"\"\" accountCollection ( \"\"\"Query the first `n` records in the collection\"\"\" first: Int \"\"\"Query the last `n` records in the collection\"\"\" last: Int \"\"\"Query values in the collection before the provided cursor\"\"\" before: Cursor \"\"\"Query values in the collection after the provided cursor\"\"\" after: Cursor \"\"\"Filters to apply to the results set when querying from the collection\"\"\" filter: AccountFilter \"\"\"Sort order to apply to the collection\"\"\" orderBy: [ AccountOrderBy !] ): AccountConnection \"\"\"A pagable collection of type `Blog`\"\"\" blogCollection ( \"\"\"Query the first `n` records in the collection\"\"\" first: Int \"\"\"Query the last `n` records in the collection\"\"\" last: Int \"\"\"Query values in the collection before the provided cursor\"\"\" before: Cursor \"\"\"Query values in the collection after the provided cursor\"\"\" after: Cursor \"\"\"Filters to apply to the results set when querying from the collection\"\"\" filter: BlogFilter \"\"\"Sort order to apply to the collection\"\"\" orderBy: [ BlogOrderBy !] ): BlogConnection \"\"\"A pagable collection of type `BlogPost`\"\"\" blogPostCollection ( \"\"\"Query the first `n` records in the collection\"\"\" first: Int \"\"\"Query the last `n` records in the collection\"\"\" last: Int \"\"\"Query values in the collection before the provided cursor\"\"\" before: Cursor \"\"\"Query values in the collection after the provided cursor\"\"\" after: Cursor \"\"\"Filters to apply to the results set when querying from the collection\"\"\" filter: BlogPostFilter \"\"\"Sort order to apply to the collection\"\"\" orderBy: [ BlogPostOrderBy !] ): BlogPostConnection \"\"\"Retrieve a record by its `ID`\"\"\" node ( \"\"\"The record's `ID`\"\"\" nodeId: ID ! ): Node } \"\"\" Boolean expression comparing fields on type \"String\" \"\"\" input StringFilter { eq: String gt: String gte: String in: [ String !] lt: String lte: String neq: String } scalar Time \"\"\" Boolean expression comparing fields on type \"Time\" \"\"\" input TimeFilter { eq: Time gt: Time gte: Time in: [ Time !] lt: Time lte: Time neq: Time } scalar UUID \"\"\" Boolean expression comparing fields on type \"UUID\" \"\"\" input UUIDFilter { eq: UUID in: [ UUID !] neq: UUID }","title":"Example Schema"},{"location":"installation/","text":"First, install pgx Then clone the repo and install using 1 2 3 git clone https://github.com/supabase/pg_graphql.git cd pg_graphql cargo pgx install pg14 --release To enable the extension in PostgreSQL we must execute a create extension statement. The extension creates its own schema/namespace named graphql to avoid naming conflicts. 1 create extension pg_graphql ;","title":"Installation"},{"location":"quickstart/","text":"If you are new to the project, start here. The easiest way to try pg_graphql is to run the interactive GraphiQL IDE demo. The demo environment launches a database, webserver and the GraphiQL IDE/API explorer with a small pre-populated schema. Requires: git docker-compose First, clone the repo 1 2 git clone https://github.com/supabase/pg_graphql.git cd pg_graphql Next, launch the demo with docker-compose. 1 docker-compose up Finally, access GraphiQL at http://localhost:4000/ .","title":"Quickstart"},{"location":"security/","text":"pg_graphql fully respects builtin PostgreSQL role and row security. Table/Column Visbility Table and column visibility in the GraphQL schema are controlled by standard PostgreSQL role permissions. Revoking SELECT access from the user/role executing queries removes that entity from the visible schema. For example: 1 revoke all privileges on public . \"Account\" from api_user ; removes the Account GraphQL type. Similarly, revoking SELECT access on a table's column will remove that field from the associated GraphQL type/s. The permissions SELECT , INSERT , UPDATE , and DELETE all impact the relevant sections of the GraphQL schema. Row Visibilty Visibility of rows in a given table can be configured using PostgreSQL's built-in row level security policies.","title":"Security"},{"location":"security/#tablecolumn-visbility","text":"Table and column visibility in the GraphQL schema are controlled by standard PostgreSQL role permissions. Revoking SELECT access from the user/role executing queries removes that entity from the visible schema. For example: 1 revoke all privileges on public . \"Account\" from api_user ; removes the Account GraphQL type. Similarly, revoking SELECT access on a table's column will remove that field from the associated GraphQL type/s. The permissions SELECT , INSERT , UPDATE , and DELETE all impact the relevant sections of the GraphQL schema.","title":"Table/Column Visbility"},{"location":"security/#row-visibilty","text":"Visibility of rows in a given table can be configured using PostgreSQL's built-in row level security policies.","title":"Row Visibilty"},{"location":"sql_interface/","text":"pg_graphql's public facing SQL interface consists of a single SQL function to resolve GraphQL requests. All other entities in the graphql schema are private. graphql.resolve description Resolves a GraphQL query, returning JSONB. signature 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 graphql . resolve ( -- graphql query/mutation query text , -- json key/values pairs for variables variables jsonb default '{}' :: jsonb , -- the name of the graphql operation in *query* to execute \"operationName\" text default null , -- extensions to include in the request extensions jsonb default null , ) returns jsonb strict volatile parallel safe language plpgsql usage 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 -- Create the extension graphqldb = create extension pg_graphql ; CREATE EXTENSION -- Create an example table graphqldb = create table book ( id int primary key , title text ); CREATE TABLE -- Insert a record graphqldb = insert into book ( id , title ) values ( 1 , 'book 1' ); INSERT 0 1 -- Query the table via GraphQL graphqldb = select graphql . resolve ( $$ query { bookCollection { edges { node { id } } } } $$ ); resolve ---------------------------------------------------------------------- { \"data\" : { \"bookCollection\" : { \"edges\" : [ { \"node\" : { \"id\" : 1 }} ] }} , \"errors\" : [] }","title":"SQL Interface"},{"location":"sql_interface/#graphqlresolve","text":"","title":"graphql.resolve"},{"location":"sql_interface/#description","text":"Resolves a GraphQL query, returning JSONB.","title":"description"},{"location":"sql_interface/#signature","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 graphql . resolve ( -- graphql query/mutation query text , -- json key/values pairs for variables variables jsonb default '{}' :: jsonb , -- the name of the graphql operation in *query* to execute \"operationName\" text default null , -- extensions to include in the request extensions jsonb default null , ) returns jsonb strict volatile parallel safe language plpgsql","title":"signature"},{"location":"sql_interface/#usage","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 -- Create the extension graphqldb = create extension pg_graphql ; CREATE EXTENSION -- Create an example table graphqldb = create table book ( id int primary key , title text ); CREATE TABLE -- Insert a record graphqldb = insert into book ( id , title ) values ( 1 , 'book 1' ); INSERT 0 1 -- Query the table via GraphQL graphqldb = select graphql . resolve ( $$ query { bookCollection { edges { node { id } } } } $$ ); resolve ---------------------------------------------------------------------- { \"data\" : { \"bookCollection\" : { \"edges\" : [ { \"node\" : { \"id\" : 1 }} ] }} , \"errors\" : [] }","title":"usage"}]}