{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>pg_graphql</code>","text":"<p>Documentation: https://supabase.github.io/pg_graphql</p> <p>Source Code: https://github.com/supabase/pg_graphql</p> <p><code>pg_graphql</code> adds GraphQL support to your PostgreSQL database.</p> <ul> <li> Performant</li> <li> Consistent</li> <li> Open Source</li> </ul>"},{"location":"#overview","title":"Overview","text":"<p><code>pg_graphql</code> is a PostgreSQL extension that enables querying the database with GraphQL using a single SQL function.</p> <p>The extension reflects a GraphQL schema from the existing SQL schema and exposes it through a SQL function, <code>graphql.resolve(...)</code>. This enables any programming language that can connect to PostgreSQL to query the database via GraphQL with no additional servers, processes, or libraries.</p>"},{"location":"#tldr","title":"TL;DR","text":"<p>The SQL schema</p> <p><pre><code>create table account(\nid serial primary key,\nemail varchar(255) not null,\ncreated_at timestamp not null,\nupdated_at timestamp not null\n);\n\ncreate table blog(\nid serial primary key,\nowner_id integer not null references account(id),\nname varchar(255) not null,\ndescription varchar(255),\ncreated_at timestamp not null,\nupdated_at timestamp not null\n);\n\ncreate type blog_post_status as enum ('PENDING', 'RELEASED');\n\ncreate table blog_post(\nid uuid not null default uuid_generate_v4() primary key,\nblog_id integer not null references blog(id),\ntitle varchar(255) not null,\nbody varchar(10000),\nstatus blog_post_status not null,\ncreated_at timestamp not null,\nupdated_at timestamp not null\n);\n</code></pre> Translates into a GraphQL schema displayed below.</p> <p>Each table receives an entrypoint in the top level <code>Query</code> type that is a pageable collection with relationships defined by its foreign keys. Tables similarly receive entrypoints in the <code>Mutation</code> type that enable bulk operations for insert, update, and delete.</p> <p></p>"},{"location":"api/","title":"API","text":"<p>In our API, each SQL table is reflected as a set of GraphQL types. At a high level, tables become types and columns/foreign keys become fields on those types.</p> <p>By default, PostgreSQL table and column names are not inflected when reflecting GraphQL  names. For example, an <code>account_holder</code> table has GraphQL type name <code>account_holder</code>. In cases where SQL entities are named using <code>snake_case</code>, enable inflection to match GraphQL/Javascript conventions e.g. <code>account_holder</code> -&gt; <code>AccountHolder</code>.</p> <p>Individual table, column, and relationship names may also be manually overridden.</p>"},{"location":"api/#querytype","title":"QueryType","text":"<p>The <code>Query</code> type is the entrypoint for all read access into the graph.</p>"},{"location":"api/#node","title":"Node","text":"<p>The <code>node</code> interface allows for retrieving records that are uniquely identifiable by a globally unique <code>nodeId: ID!</code> field. For more information about nodeId, see nodeId.</p> <p>SQL Setup <pre><code>create table \"Blog\"(\nid serial primary key,\nname varchar(255) not null,\ndescription varchar(255),\n\"createdAt\" timestamp not null,\n\"updatedAt\" timestamp not null\n);\n</code></pre></p> <p>GraphQL Types</p> QueryType <pre><code>\"\"\"The root type for querying data\"\"\"\ntype Query {\n\n  \"\"\"Retrieve a record by its `ID`\"\"\"\n  node(nodeId: ID!): Node\n\n}\n</code></pre> <p>To query the <code>node</code> interface effectively, use inline fragments to specify which fields to return for each type.</p> <p>Example</p> QueryResponse <pre><code>{\n  node(\n    nodeId: \"WyJwdWJsaWMiLCAiYmxvZyIsIDFd\"\n  ) {\n    nodeId\n    # Inline fragment for `Blog` type\n    ... on Blog {\n      name\n      description\n    }\n  }\n}\n</code></pre> <pre><code>{\n\"data\": {\n\"node\": {\n\"name\": \"Some Blog\",\n\"nodeId\": \"WyJwdWJsaWMiLCAiYmxvZyIsIDFd\",\n\"description\": \"Description of Some Blog\"\n}\n}\n}\n</code></pre>"},{"location":"api/#collections","title":"Collections","text":"<p>Each table has top level entry in the <code>Query</code> type for selecting records from that table. Collections return a connection type and can be paginated, filtered, and sorted using the available arguments.</p> <p>SQL Setup</p> <pre><code>create table \"Blog\"(\nid serial primary key,\nname varchar(255) not null,\ndescription varchar(255),\n\"createdAt\" timestamp not null,\n\"updatedAt\" timestamp not null\n);\n</code></pre> <p>GraphQL Types</p> QueryType <pre><code>\"\"\"The root type for querying data\"\"\"\ntype Query {\n\n  \"\"\"A pagable collection of type `Blog`\"\"\"\n  blogCollection(\n\n    \"\"\"Query the first `n` records in the collection\"\"\"\n    first: Int\n\n    \"\"\"Query the last `n` records in the collection\"\"\"\n    last: Int\n\n    \"\"\"Query values in the collection before the provided cursor\"\"\"\n    before: Cursor\n\n    \"\"\"Query values in the collection after the provided cursor\"\"\"\n    after: Cursor\n\n    \"\"\"Filters to apply to the results set when querying from the collection\"\"\"\n    filter: BlogFilter\n\n    \"\"\"Sort order to apply to the collection\"\"\"\n    orderBy: [BlogOrderBy!]\n  ): BlogConnection\n}\n</code></pre> <p>Connection types are the primary interface to returning records from a collection.</p> <p>Connections wrap a result set with some additional metadata.</p> BlogConnectionBlogEdgePageInfoBlogBlogOrderByBlogFilter <pre><code>type BlogConnection {\n\n  # Count of all records matching the *filter* criteria\n  totalCount: Int!\n\n  # Pagination metadata\n  pageInfo: PageInfo!\n\n  # Result set\n  edges: [BlogEdge!]!\n\n}\n</code></pre> <pre><code>type BlogEdge {\n\n  # Unique identifier of the record within the query\n  cursor: String!\n\n  # Contents of a record/row in the results set\n  node: Blog\n\n}\n</code></pre> <pre><code>type PageInfo {\n\n  # unique identifier of the first record within the query\n  startCursor: String\n\n  # unique identifier of the last record within the query\n  endCursor: String\n\n  # is another page of content available\n  hasNextPage: Boolean!\n\n  # is another page of content available\n  hasPreviousPage: Boolean!\n}\n</code></pre> <pre><code># A record from the `blog` table\ntype Blog {\n\n  # globally unique identifier\n  nodeId: ID!\n\n  # Value from `id` column\n  id: Int!\n\n  # Value from `name` column\n  name: String!\n\n  # Value from `description` column\n  description: String\n\n  # Value from `createdAt` column\n  createdAt: Datetime!\n\n  # Value from `updatedAt` column\n  updatedAt: Datetime!\n\n}\n</code></pre> <pre><code>input BlogOrderBy {\n  id: OrderByDirection\n  name: OrderByDirection\n  description: OrderByDirection\n  createdAt: OrderByDirection\n  updatedAt: OrderByDirection\n}\n</code></pre> <pre><code>input BlogFilter {\n  nodeId: IDFilter\n  id: IntFilter\n  name: StringFilter\n  description: StringFilter\n  createdAt: DatetimeFilter\n  updatedAt: DatetimeFilter\n  and: [BlogFilter!]\n  or: [BlogFilter!]\n  not: BlogFilter\n}\n</code></pre> <p>Note</p> <p>The <code>totalCount</code> field is disabled by default because it can be expensive on large tables. To enable it use a comment directive</p>"},{"location":"api/#pagination","title":"Pagination","text":"<p>Paginating forwards and backwards through collections is handled using the <code>first</code>, <code>last</code>, <code>before</code>, and <code>after</code> parameters, following the relay spec.</p> QueryType <pre><code>type Query {\n\n  blogCollection(\n\n    \"\"\"Query the first `n` records in the collection\"\"\"\n    first: Int\n\n    \"\"\"Query the last `n` records in the collection\"\"\"\n    last: Int\n\n    \"\"\"Query values in the collection before the provided cursor\"\"\"\n    before: Cursor\n\n    \"\"\"Query values in the collection after the provided cursor\"\"\"\n    after: Cursor\n\n    ...truncated...\n\n  ): BlogConnection\n}\n</code></pre> <p>Metadata relating to the current page of a result set is available on the <code>pageInfo</code> field of the connection type returned from a collection.</p> PageInfoBlogConnection <pre><code>type PageInfo {\n\n  # unique identifier of the first record within the query\n  startCursor: String\n\n  # unique identifier of the last record within the query\n  endCursor: String\n\n  # is another page of content available\n  hasNextPage: Boolean!\n\n  # is another page of content available\n  hasPreviousPage: Boolean!\n}\n</code></pre> <pre><code>type BlogConnection {\n\n  # Pagination metadata\n  pageInfo: PageInfo!\n\n  # Result set\n  edges: [BlogEdge!]!\n\n}\n</code></pre> <p>To paginate forward in the collection, use the <code>first</code> and <code>after</code> arguments. To retrieve the first page, the <code>after</code> argument should be null or absent.</p> <p>Example</p> QueryPage 1 <pre><code>{\n  blogCollection(\n    first: 2,\n    after: null\n  ) {\n    pageInfo {\n      startCursor\n      endCursor\n      hasPreviousPage\n      hasNextPage\n    }\n    edges {\n      cursor\n      node {\n        id\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n\"data\": {\n\"blogCollection\": {\n\"edges\": [\n{\n\"node\": {\n\"id\": 1\n},\n\"cursor\": \"WzFd\"\n},\n{\n\"node\": {\n\"id\": 2\n},\n\"cursor\": \"WzJd\"\n}\n],\n\"pageInfo\": {\n\"startCursor\": \"WzFd\",\n\"endCursor\": \"WzJd\",\n\"hasNextPage\": true,\n\"hasPreviousPage\": false\n}\n}\n}\n}\n</code></pre> <p>To retrieve the next page, provide the cursor value from <code>data.blogCollection.pageInfo.endCursor</code> to the <code>after</code> argument of another query.</p> QueryPage 2 <pre><code>{\n  blogCollection(\n    first: 2,\n    after: \"WzJd\"\n  ) {\n  ...truncated...\n}\n</code></pre> <pre><code>{\n\"data\": {\n\"blogCollection\": {\n\"edges\": [\n{\n\"node\": {\n\"id\": 3\n},\n\"cursor\": \"WzNd\"\n},\n{\n\"node\": {\n\"id\": 4\n},\n\"cursor\": \"WzRd\"\n}\n],\n\"pageInfo\": {\n\"startCursor\": \"WzNd\",\n\"endCursor\": \"WzRd\",\n\"hasNextPage\": false,\n\"hasPreviousPage\": true\n}\n}\n}\n}\n</code></pre> <p>once the collection has been fully enumerated, <code>data.blogConnection.pageInfo.hasNextPage</code> returns false.</p> <p>To paginate backwards through a collection, repeat the process substituting <code>first</code> -&gt; <code>last</code>, <code>after</code> -&gt; <code>before</code>, <code>hasNextPage</code> -&gt; <code>hasPreviousPage</code></p>"},{"location":"api/#filtering","title":"Filtering","text":"<p>To filter the result set, use the <code>filter</code> argument.</p> QueryType <pre><code>type Query {\n\n  blogCollection(\n\n    \"\"\"Filters to apply to the results set when querying from the collection\"\"\"\n    filter: BlogFilter\n\n    ...truncated...\n\n  ): BlogConnection\n}\n</code></pre> <p>Where the <code>&lt;Table&gt;Filter</code> type enumerates filterable fields and their associated <code>&lt;Type&gt;Filter</code>.</p> BlogFilterIntFilterStringFilterFilterIs <pre><code>input BlogFilter {\n  nodeId: IDFilter\n  id: IntFilter\n  name: StringFilter\n  description: StringFilter\n  createdAt: DatetimeFilter\n  updatedAt: DatetimeFilter\n  and: [BlogFilter!]\n  or: [BlogFilter!]\n  not: BlogFilter\n}\n</code></pre> <pre><code>\"\"\"\nBoolean expression comparing fields on type \"Int\"\n\"\"\"\ninput IntFilter {\n  eq: Int\n  gt: Int\n  gte: Int\n  in: [Int!]\n  lt: Int\n  lte: Int\n  neq: Int\n  is: FilterIs\n}\n</code></pre> <pre><code>\"\"\"\nBoolean expression comparing fields on type \"String\"\n\"\"\"\ninput StringFilter {\n  eq: String\n  gt: String\n  gte: String\n  in: [String!]\n  lt: String\n  lte: String\n  neq: String\n  is: FilterIs\n  startsWith: String\n  like: String\n  ilike: String\n  regex: String\n  iregex: String\n}\n</code></pre> <pre><code>enum FilterIs {\n  NULL\n  NOT_NULL\n}\n</code></pre> <p>The following list shows the operators that may be available on <code>&lt;Type&gt;Filter</code> types.</p> Operator Description eq Equal To neq Not Equal To gt Greater Than gte Greater Than Or Equal To in Contained by Value List lt Less Than lte Less Than Or Equal To is Null or Not Null startsWith Starts with prefix like Pattern Match. '%' as wildcard ilike Pattern Match. '%' as wildcard. Case Insensitive regex POSIX Regular Expression Match iregex POSIX Regular Expression Match. Case Insensitive <p>Not all operators are available on every <code>&lt;Type&gt;Filter</code> type. For example, <code>UUIDFilter</code> only supports <code>eq</code> and <code>neq</code> because <code>UUID</code>s are not ordered.</p> <p>Example: simple</p> QueryResult <pre><code>{\n  blogCollection(\n    filter: {id: {lt: 3}},\n  ) {\n    edges {\n      cursor\n      node {\n        id\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n\"data\": {\n\"blogCollection\": {\n\"edges\": [\n{\n\"node\": {\n\"id\": 1\n},\n\"cursor\": \"WzFd\"\n},\n{\n\"node\": {\n\"id\": 2\n},\n\"cursor\": \"WzJd\"\n}\n]\n}\n}\n}\n</code></pre> <p> Example: and/or </p> <p>Multiple filters can be combined with <code>and</code>, <code>or</code> and <code>not</code> operators. The <code>and</code> and <code>or</code> operators accept a list of <code>&lt;Type&gt;Filter</code>.</p> <code>and</code> Filter Query<code>and</code> Filter Result<code>or</code> Filter Query<code>or</code> Filter Result <pre><code>{\n  blogCollection(\n    filter: {\n      and: [\n        {id: {eq: 1}}\n        {name: {eq: \"A: Blog 1\"}}\n      ]\n    }\n  ) {\n    edges {\n      cursor\n      node {\n        id\n        name\n        description\n        createdAt\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n\"data\": {\n\"blogCollection\": {\n\"edges\": [\n{\n\"node\": {\n\"id\": 1,\n\"name\": \"A: Blog 1\",\n\"createdAt\": \"2023-07-24T04:01:09.882781\",\n\"description\": \"a desc1\"\n},\n\"cursor\": \"WzFd\"\n}\n]\n}\n}\n}\n</code></pre> <pre><code>{\n  blogCollection(\n    filter: {\n      or: [\n        {id: {eq: 1}}\n        {name: {eq: \"A: Blog 2\"}}\n      ]\n    }\n  ) {\n    edges {\n      cursor\n      node {\n        id\n        name\n        description\n        createdAt\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n\"data\": {\n\"blogCollection\": {\n\"edges\": [\n{\n\"node\": {\n\"id\": 1,\n\"name\": \"A: Blog 1\",\n\"createdAt\": \"2023-07-24T04:01:09.882781\",\n\"description\": \"a desc1\"\n},\n\"cursor\": \"WzFd\"\n},\n{\n\"node\": {\n\"id\": 2,\n\"name\": \"A: Blog 2\",\n\"createdAt\": \"2023-07-24T04:01:09.882781\",\n\"description\": \"a desc2\"\n},\n\"cursor\": \"WzJd\"\n}\n]\n}\n}\n}\n</code></pre> <p> Example: not </p> <p><code>not</code> accepts a single <code>&lt;Type&gt;Filter</code>.</p> <code>not</code> Filter Query<code>not</code> Filter Result <pre><code>{\n  blogCollection(\n    filter: {\n      not: {id: {eq: 1}}\n    }\n  ) {\n    edges {\n      cursor\n      node {\n        id\n        name\n        description\n        createdAt\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n\"data\": {\n\"blogCollection\": {\n\"edges\": [\n{\n\"node\": {\n\"id\": 2,\n\"name\": \"A: Blog 2\",\n\"createdAt\": \"2023-07-24T04:01:09.882781\",\n\"description\": \"a desc2\"\n},\n\"cursor\": \"WzJd\"\n},\n{\n\"node\": {\n\"id\": 3,\n\"name\": \"A: Blog 3\",\n\"createdAt\": \"2023-07-24T04:01:09.882781\",\n\"description\": \"a desc3\"\n},\n\"cursor\": \"WzNd\"\n},\n{\n\"node\": {\n\"id\": 4,\n\"name\": \"B: Blog 3\",\n\"createdAt\": \"2023-07-24T04:01:09.882781\",\n\"description\": \"b desc1\"\n},\n\"cursor\": \"WzRd\"\n}\n]\n}\n}\n}\n</code></pre> <p> Example: nested composition </p> <p>The <code>and</code>, <code>or</code> and <code>not</code> operators can be arbitrarily nested inside each other.</p> QueryResult <pre><code>{\n  blogCollection(\n    filter: {\n      or: [\n        { id: { eq: 1 } }\n        { id: { eq: 2 } }\n        { and: [{ id: { eq: 3 }, not: { name: { eq: \"A: Blog 2\" } } }] }\n      ]\n    }\n  ) {\n    edges {\n      cursor\n      node {\n        id\n        name\n        description\n        createdAt\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n\"data\": {\n\"blogCollection\": {\n\"edges\": [\n{\n\"node\": {\n\"id\": 1,\n\"name\": \"A: Blog 1\",\n\"createdAt\": \"2023-07-24T04:01:09.882781\",\n\"description\": \"a desc1\"\n},\n\"cursor\": \"WzFd\"\n},\n{\n\"node\": {\n\"id\": 2,\n\"name\": \"A: Blog 2\",\n\"createdAt\": \"2023-07-24T04:01:09.882781\",\n\"description\": \"a desc2\"\n},\n\"cursor\": \"WzJd\"\n},\n{\n\"node\": {\n\"id\": 3,\n\"name\": \"A: Blog 3\",\n\"createdAt\": \"2023-07-24T04:01:09.882781\",\n\"description\": \"a desc3\"\n},\n\"cursor\": \"WzNd\"\n}\n]\n}\n}\n}\n</code></pre> <p> Example: empty </p> <p>Empty filters are ignored, i.e. they behave as if the operator was not specified at all.</p> QueryResult <pre><code>{\n  blogCollection(\n    filter: {\n      and: [], or: [], not: {}\n    }\n  ) {\n    edges {\n      cursor\n      node {\n        id\n        name\n        description\n        createdAt\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n\"data\": {\n\"blogCollection\": {\n\"edges\": [\n{\n\"node\": {\n\"id\": 1,\n\"name\": \"A: Blog 1\",\n\"createdAt\": \"2023-07-24T04:01:09.882781\",\n\"description\": \"a desc1\"\n},\n\"cursor\": \"WzFd\"\n},\n{\n\"node\": {\n\"id\": 2,\n\"name\": \"A: Blog 2\",\n\"createdAt\": \"2023-07-24T04:01:09.882781\",\n\"description\": \"a desc2\"\n},\n\"cursor\": \"WzJd\"\n},\n{\n\"node\": {\n\"id\": 3,\n\"name\": \"A: Blog 3\",\n\"createdAt\": \"2023-07-24T04:01:09.882781\",\n\"description\": \"a desc3\"\n},\n\"cursor\": \"WzNd\"\n},\n{\n\"node\": {\n\"id\": 4,\n\"name\": \"B: Blog 3\",\n\"createdAt\": \"2023-07-24T04:01:09.882781\",\n\"description\": \"b desc1\"\n},\n\"cursor\": \"WzRd\"\n}\n]\n}\n}\n}\n</code></pre> <p> Example: implicit and </p> <p>Multiple column filters at the same level will be implicitly combined with boolean <code>and</code>. In the following example the <code>id: {eq: 1}</code> and <code>name: {eq: \"A: Blog 1\"}</code> will be <code>and</code>ed.</p> QueryResult <pre><code>{\n  blogCollection(\n    filter: {\n      # Equivalent to not: { and: [{id: {eq: 1}}, {name: {eq: \"A: Blog 1\"}}]}\n      not: {\n        id: {eq: 1}\n        name: {eq: \"A: Blog 1\"}\n      }\n    }\n  ) {\n    edges {\n      cursor\n      node {\n        id\n        name\n        description\n        createdAt\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n\"data\": {\n\"blogCollection\": {\n\"edges\": [\n{\n\"node\": {\n\"id\": 2,\n\"name\": \"A: Blog 2\",\n\"createdAt\": \"2023-07-24T04:01:09.882781\",\n\"description\": \"a desc2\"\n},\n\"cursor\": \"WzJd\"\n},\n{\n\"node\": {\n\"id\": 3,\n\"name\": \"A: Blog 3\",\n\"createdAt\": \"2023-07-24T04:01:09.882781\",\n\"description\": \"a desc3\"\n},\n\"cursor\": \"WzNd\"\n},\n{\n\"node\": {\n\"id\": 4,\n\"name\": \"B: Blog 3\",\n\"createdAt\": \"2023-07-24T04:01:09.882781\",\n\"description\": \"b desc1\"\n},\n\"cursor\": \"WzRd\"\n}\n]\n}\n}\n}\n</code></pre> <p>This means that an <code>and</code> filter can be often be simplified. In the following example all queries are equivalent and produce the same result.</p> Original <code>and</code> QuerySimplified <code>and</code> QueryEven More Simplified QueryResult <pre><code>{\n  blogCollection(\n    filter: {\n      and: [\n        {id: {gt: 0}}\n        {id: {lt: 2}}\n        {name: {eq: \"A: Blog 1\"}}\n      ]\n    }\n  ) {\n    edges {\n      cursor\n      node {\n        id\n        name\n        description\n        createdAt\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n  blogCollection(\n    filter: {\n        id: {gt: 0}\n        id: {lt: 2}\n        name: {eq: \"A: Blog 1\"}\n    }\n  ) {\n    edges {\n      cursor\n      node {\n        id\n        name\n        description\n        createdAt\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n  blogCollection(\n    filter: {\n        id: {gt: 0, lt: 2}\n        name: {eq: \"A: Blog 1\"}\n    }\n  ) {\n    edges {\n      cursor\n      node {\n        id\n        name\n        description\n        createdAt\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n\"data\": {\n\"blogCollection\": {\n\"edges\": [\n{\n\"node\": {\n\"id\": 2,\n\"name\": \"A: Blog 2\",\n\"createdAt\": \"2023-07-24T04:01:09.882781\",\n\"description\": \"a desc2\"\n},\n\"cursor\": \"WzJd\"\n},\n{\n\"node\": {\n\"id\": 3,\n\"name\": \"A: Blog 3\",\n\"createdAt\": \"2023-07-24T04:01:09.882781\",\n\"description\": \"a desc3\"\n},\n\"cursor\": \"WzNd\"\n},\n{\n\"node\": {\n\"id\": 4,\n\"name\": \"B: Blog 3\",\n\"createdAt\": \"2023-07-24T04:01:09.882781\",\n\"description\": \"b desc1\"\n},\n\"cursor\": \"WzRd\"\n}\n]\n}\n}\n}\n</code></pre> <p>Be aware that the above simplification only works for the <code>and</code> operator. If you try it with an <code>or</code> operator it will behave like an <code>and</code>.</p> QueryResult <pre><code>{\n  blogCollection(\n    filter: {\n      # This is really an `and` in `or`'s clothing\n      or: {\n        id: {eq: 1}\n        name: {eq: \"A: Blog 2\"}\n      }\n    }\n  ) {\n    edges {\n      cursor\n      node {\n        id\n        name\n        description\n        createdAt\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n\"data\": {\n\"blogCollection\": {\n\"edges\": []\n}\n}\n}\n</code></pre> <p>This is because according to the rules of GraphQL list input coercion, if a value passed to an input of list type is not a list, then it is coerced to a list of a single item. So in the above example <code>or: {id: {eq: 1}, name: {eq: \"A: Blog 2}}</code> will be coerced into <code>or: [{id: {eq: 1}, name: {eq: \"A: Blog 2}}]</code> which is equivalent to <code>or: [and: [{id: {eq: 1}}, {name: {eq: \"A: Blog 2}}}]</code> due to implicit <code>and</code>ing.</p> <p>Note</p> <p>Avoid naming your columns <code>and</code>, <code>or</code> or <code>not</code>. If you do, the corresponding filter operator will not be available for use.</p> <p>The <code>and</code>, <code>or</code> and <code>not</code> operators also work with update and delete mutations.</p>"},{"location":"api/#ordering","title":"Ordering","text":"<p>The default order of results is defined by the underlying table's primary key column in ascending order. That default can be overridden by passing an array of <code>&lt;Table&gt;OrderBy</code> to the collection's <code>orderBy</code> argument.</p> QueryTypeBlogOrderByOrderByDirection <pre><code>type Query {\n\n  blogCollection(\n\n    \"\"\"Sort order to apply to the collection\"\"\"\n    orderBy: [BlogOrderBy!]\n\n    ...truncated...\n\n  ): BlogConnection\n}\n</code></pre> <pre><code>input BlogOrderBy {\n  id: OrderByDirection\n  name: OrderByDirection\n  description: OrderByDirection\n  createdAt: OrderByDirection\n  updatedAt: OrderByDirection\n}\n</code></pre> <pre><code>\"\"\"Defines a per-field sorting order\"\"\"\nenum OrderByDirection {\n  \"\"\"Ascending order, nulls first\"\"\"\n  AscNullsFirst\n\n  \"\"\"Ascending order, nulls last\"\"\"\n  AscNullsLast\n\n  \"\"\"Descending order, nulls first\"\"\"\n  DescNullsFirst\n\n  \"\"\"Descending order, nulls last\"\"\"\n  DescNullsLast\n}\n</code></pre> <p>Example</p> QueryResult <pre><code>{\n  blogCollection(\n    orderBy: [{id: DescNullsLast}]\n  ) {\n    edges {\n      node {\n        id\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n\"data\": {\n\"blogCollection\": {\n\"edges\": [\n{\n\"node\": {\n\"id\": 4\n}\n},\n{\n\"node\": {\n\"id\": 3\n}\n},\n{\n\"node\": {\n\"id\": 2\n}\n},\n{\n\"node\": {\n\"id\": 1\n}\n}\n]\n}\n}\n}\n</code></pre> <p>Note, only one key value pair may be provided to each element of the input array. For example, <code>[{name: AscNullsLast}, {id: AscNullFirst}]</code> is valid. Passing multiple key value pairs in a single element of the input array e.g. <code>[{name: AscNullsLast, id: AscNullFirst}]</code>, is invalid.</p>"},{"location":"api/#mutationtype","title":"MutationType","text":"<p>The <code>Mutation</code> type is the entrypoint for mutations/edits.</p> <p>Each table has top level entry in the <code>Mutation</code> type for inserting <code>insertInto&lt;Table&gt;Collection</code>, updating <code>update&lt;Table&gt;Collection</code> and deleting <code>deleteFrom&lt;Table&gt;Collection</code>.</p> <p>SQL Setup <pre><code>create table \"Blog\"(\nid serial primary key,\nname varchar(255) not null,\ndescription varchar(255),\n\"createdAt\" timestamp not null default now(),\n\"updatedAt\" timestamp\n);\n</code></pre></p> MutationType <pre><code>\"\"\"The root type for creating and mutating data\"\"\"\ntype Mutation {\n\n  \"\"\"Adds one or more `BlogInsertResponse` records to the collection\"\"\"\n  insertIntoBlogCollection(\n\n    \"\"\"Records to add to the Blog collection\"\"\"\n    objects: [BlogInsertInput!]!\n\n  ): BlogInsertResponse\n\n  \"\"\"Updates zero or more records in the collection\"\"\"\n  updateBlogCollection(\n    \"\"\"\n    Fields that are set will be updated for all records matching the `filter`\n    \"\"\"\n    set: BlogUpdateInput!\n\n    \"\"\"Restricts the mutation's impact to records matching the critera\"\"\"\n    filter: BlogFilter\n\n    \"\"\"\n    The maximum number of records in the collection permitted to be affected\n    \"\"\"\n    atMost: Int! = 1\n\n  ): BlogUpdateResponse!\n\n  \"\"\"Deletes zero or more records from the collection\"\"\"\n  deleteFromBlogCollection(\n    \"\"\"Restricts the mutation's impact to records matching the critera\"\"\"\n    filter: BlogFilter\n\n    \"\"\"\n    The maximum number of records in the collection permitted to be affected\n    \"\"\"\n    atMost: Int! = 1\n\n  ): BlogDeleteResponse!\n\n}\n</code></pre>"},{"location":"api/#insert","title":"Insert","text":"<p>To add records to a collection, use the <code>insertInto&lt;Table&gt;Collection</code> field on the <code>Mutation</code> type.</p> <p>SQL Setup <pre><code>create table \"Blog\"(\nid serial primary key,\nname varchar(255) not null,\ndescription varchar(255),\n\"createdAt\" timestamp not null default now(),\n\"updatedAt\" timestamp\n);\n</code></pre></p> <p>GraphQL Types</p> MutationTypeBlogInsertInputBlogInsertResponse <pre><code>\"\"\"The root type for creating and mutating data\"\"\"\ntype Mutation {\n\n  \"\"\"Adds one or more `BlogInsertResponse` records to the collection\"\"\"\n  insertIntoBlogCollection(\n\n    \"\"\"Records to add to the Blog collection\"\"\"\n    objects: [BlogInsertInput!]!\n\n  ): BlogInsertResponse\n\n}\n</code></pre> <pre><code>input BlogInsertInput {\n  name: String\n  description: String\n  createdAt: Datetime\n  updatedAt: Datetime\n}\n</code></pre> <pre><code>type BlogInsertResponse {\n  \"\"\"Count of the records impacted by the mutation\"\"\"\n  affectedCount: Int!\n\n  \"\"\"Array of records impacted by the mutation\"\"\"\n  records: [Blog!]!\n}\n</code></pre> <p>Where elements in the <code>objects</code> array are inserted into the underlying table.</p> <p>Example</p> QueryResult <pre><code>mutation {\n  insertIntoBlogCollection(\n    objects: [\n      {name: \"foo\"},\n      {name: \"bar\"},\n    ]\n  ) {\n    affectedCount\n    records {\n      id\n      name\n    }\n  }\n}\n</code></pre> <pre><code>{\n\"data\": {\n\"insertIntoBlogCollection\": {\n\"records\": [\n{\n\"id\": 1,\n\"name\": \"foo\"\n},\n{\n\"id\": 2,\n\"name\": \"bar\"\n}\n],\n\"affectedCount\": 2\n}\n}\n}\n</code></pre>"},{"location":"api/#update","title":"Update","text":"<p>To update records in a collection, use the <code>update&lt;Table&gt;Collection</code> field on the <code>Mutation</code> type.</p> <p>SQL Setup <pre><code>create table \"Blog\"(\nid serial primary key,\nname varchar(255) not null,\ndescription varchar(255),\n\"createdAt\" timestamp not null default now(),\n\"updatedAt\" timestamp\n);\n</code></pre></p> <p>GraphQL Types</p> MutationTypeBlogUpdateInputBlogUpdateResponse <pre><code>\"\"\"The root type for creating and mutating data\"\"\"\ntype Mutation {\n\n  \"\"\"Updates zero or more records in the collection\"\"\"\n  updateBlogCollection(\n    \"\"\"\n    Fields that are set will be updated for all records matching the `filter`\n    \"\"\"\n    set: BlogUpdateInput!\n\n    \"\"\"Restricts the mutation's impact to records matching the critera\"\"\"\n    filter: BlogFilter\n\n    \"\"\"\n    The maximum number of records in the collection permitted to be affected\n    \"\"\"\n    atMost: Int! = 1\n\n  ): BlogUpdateResponse!\n\n}\n</code></pre> <pre><code>input BlogUpdateInput {\n  name: String\n  description: String\n  createdAt: Datetime\n  updatedAt: Datetime\n}\n</code></pre> <pre><code>type BlogUpdateResponse {\n\n  \"\"\"Count of the records impacted by the mutation\"\"\"\n  affectedCount: Int!\n\n  \"\"\"Array of records impacted by the mutation\"\"\"\n  records: [Blog!]!\n\n}\n</code></pre> <p>Where the <code>set</code> argument is a key value pair describing the values to update, <code>filter</code> controls which records should be updated, and <code>atMost</code> restricts the maximum number of records that may be impacted. If the number of records impacted by the mutation exceeds the <code>atMost</code> parameter the operation will return an error.</p> <p>Example</p> QueryResult <pre><code>mutation {\n  updateBlogCollection(\n    set: {name: \"baz\"}\n    filter: {id: {eq: 1}}\n  ) {\n    affectedCount\n    records {\n      id\n      name\n    }\n  }\n}\n</code></pre> <pre><code>{\n\"data\": {\n\"updateBlogCollection\": {\n\"records\": [\n{\n\"id\": 1,\n\"name\": \"baz\"\n}\n],\n\"affectedCount\": 1\n}\n}\n}\n</code></pre>"},{"location":"api/#delete","title":"Delete","text":"<p>To remove records from a collection, use the <code>deleteFrom&lt;Table&gt;Collection</code> field on the <code>Mutation</code> type.</p> <p>SQL Setup <pre><code>create table \"Blog\"(\nid serial primary key,\nname varchar(255) not null,\ndescription varchar(255),\n\"createdAt\" timestamp not null default now(),\n\"updatedAt\" timestamp\n);\n</code></pre></p> <p>GraphQL Types</p> MutationTypeBlogFilterBlogDeleteResponse <pre><code>\"\"\"The root type for creating and mutating data\"\"\"\ntype Mutation {\n\n  \"\"\"Deletes zero or more records from the collection\"\"\"\n  deleteFromBlogCollection(\n    \"\"\"Restricts the mutation's impact to records matching the critera\"\"\"\n    filter: BlogFilter\n\n    \"\"\"\n    The maximum number of records in the collection permitted to be affected\n    \"\"\"\n    atMost: Int! = 1\n\n  ): BlogDeleteResponse!\n\n}\n</code></pre> <pre><code>input BlogFilter {\n  id: IntFilter\n  name: StringFilter\n  description: StringFilter\n  createdAt: DatetimeFilter\n  updatedAt: DatetimeFilter\n  and: [BlogFilter!]\n  or: [BlogFilter!]\n  not: BlogFilter\n}\n</code></pre> <pre><code>type BlogDeleteResponse {\n  \"\"\"Count of the records impacted by the mutation\"\"\"\n  affectedCount: Int!\n\n  \"\"\"Array of records impacted by the mutation\"\"\"\n  records: [Blog!]!\n}\n</code></pre> <p>Where <code>filter</code> controls which records should be deleted and <code>atMost</code> restricts the maximum number of records that may be deleted. If the number of records impacted by the mutation exceeds the <code>atMost</code> parameter the operation will return an error.</p> <p>Example</p> QueryResult <pre><code>mutation {\n  deleteFromBlogCollection(\n    filter: {id: {eq: 1}}\n  ) {\n    affectedCount\n    records {\n      id\n      name\n    }\n  }\n}\n</code></pre> <pre><code>{\n\"data\": {\n\"deleteFromBlogCollection\": {\n\"records\": [\n{\n\"id\": 1,\n\"name\": \"baz\"\n}\n],\n\"affectedCount\": 1\n}\n}\n}\n</code></pre>"},{"location":"api/#concepts","title":"Concepts","text":""},{"location":"api/#nodeid","title":"nodeId","text":"<p>The base GraphQL type for every table with a primary key is automatically assigned a <code>nodeId: ID!</code> field. That value, can be passed to the node entrypoint of the <code>Query</code> type to retrieve its other fields. <code>nodeId</code> may also be used as a caching key.</p> <p>relay support</p> <p>By default relay expects the <code>ID</code> field for types to have the name <code>id</code>. pg_graphql uses <code>nodeId</code> by default to avoid conflicting with user defined <code>id</code> columns. You can configure relay to work with pg_graphql's <code>nodeId</code> field with relay's <code>nodeInterfaceIdField</code> option. More info available here.</p> <p>SQL Setup <pre><code>create table \"Blog\"(\nid serial primary key,\nname varchar(255) not null\n);\n</code></pre></p> <p>GraphQL Types</p> Blog <pre><code>type Blog {\nnodeId: ID! # this field\nid: Int!\nname: String!\n}\n</code></pre>"},{"location":"api/#relationships","title":"Relationships","text":"<p>Relationships between collections in the Graph are derived from foreign keys.</p>"},{"location":"api/#one-to-many","title":"One-to-Many","text":"<p>A foreign key on table A referencing table B defines a one-to-many relationship from table A to table B.</p> <p>SQL Setup <pre><code>create table \"Blog\"(\nid serial primary key,\nname varchar(255) not null\n);\n\ncreate table \"BlogPost\"(\nid serial primary key,\n\"blogId\" integer not null references \"Blog\"(id),\ntitle varchar(255) not null,\nbody varchar(10000)\n);\n</code></pre></p> <p>GraphQL Types</p> Blog <pre><code>type Blog {\n\n# globally unique identifier\nnodeId: ID!\n\nid: Int!\nname: String!\ndescription: String\n\nblogPostCollection(\n\"\"\"Query the first `n` records in the collection\"\"\"\nfirst: Int\n\n\"\"\"Query the last `n` records in the collection\"\"\"\nlast: Int\n\n\"\"\"Query values in the collection before the provided cursor\"\"\"\nbefore: Cursor\n\n\"\"\"Query values in the collection after the provided cursor\"\"\"\nafter: Cursor\n\n\"\"\"Filters to apply to the results set when querying from the collection\"\"\"\nfilter: BlogPostFilter\n\n\"\"\"Sort order to apply to the collection\"\"\"\norderBy: [BlogPostOrderBy!]\n): BlogPostConnection\n\n}\n</code></pre> <p>Where <code>blogPostCollection</code> exposes the full <code>Query</code> interface to <code>BlogPost</code>s.</p> <p>Example</p> QueryResult <pre><code>{\n  blogCollection {\n    edges {\n      node {\n        name\n        blogPostCollection {\n          edges {\n            node {\n              id\n              title\n            }\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n\"data\": {\n\"blogCollection\": {\n\"edges\": [\n{\n\"node\": {\n\"name\": \"pg_graphql blog\",\n\"blogPostCollection\": {\n\"edges\": [\n{\n\"node\": {\n\"id\": 2,\n\"title\": \"fIr3t p0sT\"\n}\n},\n{\n\"node\": {\n\"id\": 3,\n\"title\": \"graphql with postgres\"\n}\n}\n]\n}\n}\n}\n]\n}\n}\n}\n</code></pre>"},{"location":"api/#many-to-one","title":"Many-to-One","text":"<p>A foreign key on table A referencing table B defines a many-to-one relationship from table B to table A.</p> <p>SQL Setup <pre><code>create table \"Blog\"(\nid serial primary key,\nname varchar(255) not null\n);\n\ncreate table \"BlogPost\"(\nid serial primary key,\n\"blogId\" integer not null references \"Blog\"(id),\ntitle varchar(255) not null,\nbody varchar(10000)\n);\n</code></pre></p> <p>GraphQL Types</p> BlogPost <pre><code>type BlogPost {\nnodeId: ID!\nid: Int!\nblogId: Int!\ntitle: String!\nbody: String\n\nblog: Blog\n}\n</code></pre> <p>Where <code>blog</code> exposes the <code>Blog</code> record associated with the <code>BlogPost</code>.</p> QueryResult <pre><code>{\n  blogPostCollection {\n    edges {\n      node {\n        title\n        blog {\n          name\n        }\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n\"data\": {\n\"blogPostCollection\": {\n\"edges\": [\n{\n\"node\": {\n\"blog\": {\n\"name\": \"pg_graphql blog\"\n},\n\"title\": \"fIr3t p0sT\"\n}\n},\n{\n\"node\": {\n\"blog\": {\n\"name\": \"pg_graphql blog\"\n},\n\"title\": \"graphql with postgres\"\n}\n}\n]\n}\n}\n}\n</code></pre>"},{"location":"api/#one-to-one","title":"One-to-One","text":"<p>A one-to-one relationship is defined by a foreign key on table A referencing table B where the columns making up the foreign key on table A are unique.</p> <p>SQL Setup <pre><code>create table \"EmailAddress\"(\nid serial primary key,\naddress text unique not null\n);\n\ncreate table \"Employee\"(\nid serial primary key,\nname text not null,\nemail_address_id int unique references \"EmailAddress\"(id)\n);\n</code></pre></p> <p>GraphQL Types</p> EmployeeEmailAddress <pre><code>type Employee {\nnodeId: ID!\nid: Int!\nname: String!\nemailAddressId: Int\nemailAddress: EmailAddress\n}\n</code></pre> <pre><code>type EmailAddress {\nnodeId: ID!\nid: Int!\naddress: String!\nemployee: Employee\n}\n</code></pre> <p>Example</p> QueryResult <pre><code>{\n  employeeCollection {\n    edges {\n      node {\n        name\n        emailAddress {\n          address\n          employee {\n            name\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n\"data\": {\n\"employeeCollection\": {\n\"edges\": [\n{\n\"node\": {\n\"name\": \"Foo Barington\",\n\"emailAddress\": {\n\"address\": \"foo@bar.com\",\n\"employee\": {\n\"name\": \"Foo Barington\"\n}\n}\n}\n}\n]\n}\n}\n}\n</code></pre>"},{"location":"api/#custom-scalars","title":"Custom Scalars","text":"<p>Due to differences among the types supported by PostgreSQL, JSON, and GraphQL, <code>pg_graphql</code> adds several new Scalar types to handle PostgreSQL builtins that require special handling.</p>"},{"location":"api/#json","title":"JSON","text":"<p><code>pg_graphql</code> serializes <code>json</code> and <code>jsonb</code> data types as <code>String</code> under the custom scalar name <code>JSON</code>.</p> <pre><code>scalar JSON\n</code></pre> <p>Example</p> <p>Given the setup</p> SQLGraphQL <pre><code>create table \"User\"(\nid bigserial primary key,\nconfig jsonb\n);\n\ninsert into \"User\"(config)\nvalues (jsonb_build_object('palette', 'dark-mode'));\n</code></pre> <pre><code>type User {\nnodeId: ID!\nid: BigInt!\nconfig: JSON\n}\n</code></pre> <p>The query</p> <pre><code>{\n  userCollection {\n    edges {\n      node {\n        config\n      }\n    }\n  }\n}\n</code></pre> <p>The returns the following data. Note that <code>config</code> is serialized as a string</p> <pre><code>{\n\"data\": {\n\"userCollection\": {\n\"edges\": [\n{\n\"node\": {\n\"config\": \"{\\\"palette\\\": \\\"dark-mode\\\"}\"\n}\n}\n]\n}\n}\n}\n</code></pre> <p>Use serialized JSON strings when updating or inserting <code>JSON</code> fields via the GraphQL API.</p> <p>JSON does not currently support filtering.</p>"},{"location":"api/#bigint","title":"BigInt","text":"<p>PostgreSQL <code>bigint</code> and <code>bigserial</code> types are 64 bit integers. In contrast, JSON supports 32 bit integers.</p> <p>Since PostgreSQL <code>bigint</code> values may be outside the min/max range allowed by JSON, they are represented in the GraphQL schema as <code>BigInt</code>s and values are serialized as strings.</p> <pre><code>scalar BigInt\n\ninput BigIntFilter {\n  eq: BigInt\n  gt: BigInt\n  gte: BigInt\n  in: [BigInt!]\n  lt: BigInt\n  lte: BigInt\n  neq: BigInt\n  is: FilterIs\n}\n</code></pre> <p>Example</p> <p>Given the setup</p> SQLGraphQL <pre><code>create table \"Person\"(\nid bigserial primary key,\nname text\n);\n\ninsert into \"Person\"(name)\nvalues ('J. Bazworth');\n</code></pre> <pre><code>type Person {\nnodeId: ID!\nid: BigInt!\nname: String\n}\n</code></pre> <p>The query</p> <pre><code>{\n  personCollection {\n    edges {\n      node {\n        id\n        name\n      }\n    }\n  }\n}\n</code></pre> <p>The returns the following data. Note that <code>id</code> is serialized as a string</p> <pre><code>{\n\"data\": {\n\"personCollection\": {\n\"edges\": [\n{\n\"node\": {\n\"id\": \"1\",\n\"name\": \"Foo Barington\",\n}\n}\n]\n}\n}\n}\n</code></pre>"},{"location":"api/#bigfloat","title":"BigFloat","text":"<p>PostgreSQL's <code>numeric</code> type supports arbitrary precision floating point values. JSON's <code>float</code> is limited to 64-bit precision.</p> <p>Since a PostgreSQL <code>numeric</code> may require more precision than can be handled by JSON, <code>numeric</code> types are represented in the GraphQL schema as <code>BigFloat</code> and values are serialized as strings.</p> <pre><code>scalar BigFloat\n\ninput BigFloatFilter {\n  eq: BigFloat\n  gt: BigFloat\n  gte: BigFloat\n  in: [BigFloat!]\n  lt: BigFloat\n  lte: BigFloat\n  neq: BigFloat\n  is: FilterIs\n}\n</code></pre> <p>Example</p> <p>Given the SQL setup</p> <pre><code>create table \"GeneralLedger\"(\nid serial primary key,\namount numeric(10,2)\n);\n\ninsert into \"GeneralLedger\"(amount)\nvalues (22.15);\n</code></pre> <p>The query</p> <pre><code>{\n  generalLedgerCollection {\n    edges {\n      node {\n        id\n        amount\n      }\n    }\n  }\n}\n</code></pre> <p>The returns the following data. Note that <code>amount</code> is serialized as a string</p> <pre><code>{\n\"data\": {\n\"generalLedgerCollection\": {\n\"edges\": [\n{\n\"node\": {\n\"id\": 1,\n\"amount\": \"22.15\",\n}\n}\n]\n}\n}\n}\n</code></pre>"},{"location":"api/#opaque","title":"Opaque","text":"<p>PostgreSQL's type system is extensible and not all types handle all operations e.g. filtering with <code>like</code>. To account for these, <code>pg_graphql</code> introduces a scalar <code>Opaque</code> type. The <code>Opaque</code> type uses PostgreSQL's <code>to_json</code> method to serialize values. That allows complex or unknown types to be included in the schema by delegating handling to the client.</p> <pre><code>scalar Opaque\n\ninput OpaqueFilter {\n  eq: Opaque\n  is: FilterIs\n}\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#100","title":"1.0.0","text":"<ul> <li>Initial release</li> </ul>"},{"location":"changelog/#101","title":"1.0.1","text":"<ul> <li>feature: Add support for Postgres 15</li> </ul>"},{"location":"changelog/#102","title":"1.0.2","text":"<ul> <li>bugfix: Correct inconsistent treatment of null literals</li> </ul>"},{"location":"changelog/#110","title":"1.1.0","text":"<ul> <li>feature: Add support for Views, Materialized Views, and Foreign Tables</li> <li>feature: Add support for filtering on <code>is null</code> and <code>is not null</code></li> <li>feature: User configurable page size</li> <li>bugfix: Remove requirement for <code>insert</code> permission on every column for inserts to succeed</li> <li>bugfix: <code>hasNextPage</code> and <code>hasPreviousPage</code> during reverse pagination were backwards</li> </ul>"},{"location":"changelog/#120","title":"1.2.0","text":"<ul> <li>feature: <code>String</code> type filters support <code>ilike</code>, <code>like</code>, <code>startsWith</code></li> <li>feature: Support for <code>@skip</code> and <code>@include</code> directives</li> <li>feature: Custom descriptions via comment directive <code>@graphql({\"description\": ...})</code></li> <li>bugfix: Unknown types are represented in GraphQL schema as <code>Opaque</code> rather than <code>String</code></li> <li>bugfix: PostgreSQL type modifiers, e.g. char(n), no longer truncate excess text</li> <li>bugfix: Creating a new enum variant between existing variants no longer errors</li> </ul>"},{"location":"changelog/#121","title":"1.2.1","text":"<ul> <li>feature: <code>String</code> type filters support <code>regex</code>, <code>iregex</code></li> <li>feature: computed relationships via functions returning setof</li> <li>bugfix: function based computed columns with same name no longer error</li> </ul>"},{"location":"changelog/#122","title":"1.2.2","text":"<ul> <li>feature: reproducible builds</li> </ul>"},{"location":"changelog/#123","title":"1.2.3","text":"<ul> <li>bugfix: enums not on the roles <code>search_path</code> are excluded from introspection</li> <li>bugfix: remove duplicate Enum registration</li> <li>bugfix: foreign keys on non-null columns produce non-null GraphQL relationships</li> </ul>"},{"location":"changelog/#130","title":"1.3.0","text":"<ul> <li>rename enum variants with comment directive <code>@graphql({\"mappings\": \"sql-value\": \"graphql_value\"\"})</code></li> <li>bugfix: query with more than 50 fields fails</li> <li>bugfix: @skip and @include directives missing from introspection schema</li> <li>feature: Support for <code>and</code>, <code>or</code> and <code>not</code> operators in filters</li> <li>bugfix: queries failed to run if the database was in read-only replica mode</li> </ul>"},{"location":"changelog/#master","title":"master","text":""},{"location":"computed_fields/","title":"Computed Fields","text":""},{"location":"computed_fields/#computed-values","title":"Computed Values","text":""},{"location":"computed_fields/#postgresql-builtin-preferred","title":"PostgreSQL Builtin (Preferred)","text":"<p>PostgreSQL has a builtin method for adding generated columns to tables. Generated columns are reflected identically to non-generated columns. This is the recommended approach to adding computed fields when your computation meets the restrictions. Namely:</p> <ul> <li>expression must be immutable</li> <li>expression may only reference the current row</li> </ul> <p>For example: <pre><code>begin;\ncomment on schema public is '@graphql({\"inflect_names\": true})';\ncreate table public.account(\nid serial primary key,\nfirst_name varchar(255) not null,\nlast_name varchar(255) not null,\n-- Computed Column\nfull_name text generated always as (first_name || ' ' ||  last_name) stored\n);\ninsert into public.account(first_name, last_name)\nvalues\n('Foo', 'Fooington');\nselect jsonb_pretty(\ngraphql.resolve($$\n{\naccountCollection {\nedges {\nnode {\nid\nfirstName\nlastName\nfullName\n}\n}\n}\n}\n$$)\n);\njsonb_pretty                     ------------------------------------------------------\n{                                                   +\n\"data\": {                                       +\n\"accountCollection\": {                      +\n\"edges\": [                              +\n{                                   +\n\"node\": {                       +\n\"id\": 1,                    +\n\"fullName\": \"Foo Fooington\",+\n\"lastName\": \"Fooington\",    +\n\"firstName\": \"Foo\"          +\n}                               +\n}                                   +\n]                                       +\n}                                           +\n}                                               +\n}\n(1 row)\n\nrollback;\n</code></pre></p>"},{"location":"computed_fields/#extending-types-with-functions","title":"Extending Types with Functions","text":"<p>For arbitrary computations that do not meet the requirements for generated columns, a table's reflected GraphQL type can be extended by creating a function that:</p> <ul> <li>accepts a single argument of the table's tuple type</li> </ul> <pre><code>begin;\ncomment on schema public is '@graphql({\"inflect_names\": true})';\ncreate table public.account(\nid serial primary key,\nfirst_name varchar(255) not null,\nlast_name varchar(255) not null,\nparent_id int references account(id)\n);\n-- Extend with function\ncreate function public._full_name(rec public.account)\nreturns text\nimmutable\nstrict\nlanguage sql\nas $$\nselect format('%s %s', rec.first_name, rec.last_name)\n$$;\ninsert into public.account(first_name, last_name, parent_id)\nvalues\n('Foo', 'Fooington', 1);\nselect jsonb_pretty(\ngraphql.resolve($$\n{\naccountCollection {\nedges {\nnode {\nid\nfirstName\nlastName\nfullName\nparent {\nfullName\n}\n}\n}\n}\n}\n$$)\n);\njsonb_pretty                       ---------------------------------------------------------\n{                                                      +\n\"data\": {                                          +\n\"accountCollection\": {                         +\n\"edges\": [                                 +\n{                                      +\n\"node\": {                          +\n\"id\": 1,                       +\n\"parent\": {                    +\n\"fullName\": \"Foo Fooington\"+\n},                             +\n\"fullName\": \"Foo Fooington\",   +\n\"lastName\": \"Fooington\",       +\n\"firstName\": \"Foo\"             +\n}                                  +\n}                                      +\n]                                          +\n}                                              +\n}                                                  +\n}\n(1 row)\n\nrollback;\n</code></pre>"},{"location":"computed_fields/#computed-relationships","title":"Computed Relationships","text":"<p>Computed relations can be helpful to express relationships:</p> <ul> <li>between entities that don't support foreign keys</li> <li>too complex to be expressed via a foreign key</li> </ul> <p>If the relationship is simple, but involves an entity that does not support foreign keys e.g. Foreign Data Wrappers / Views, defining a comment directive is the easiest solution. See the view doc for a complete example. Note that for entities that do not support a primary key, like views, you must define one using a comment directive to use them in a computed relationship.</p> <p>Alternatively, if the relationship is complex, or you need compatibility with PostgREST, you can define a relationship using set returning functions.</p>"},{"location":"computed_fields/#to-one","title":"To-One","text":"<p>To One relationships can be defined using a function that returns <code>setof &lt;entity&gt; rows 1</code></p> <p>For example <pre><code>create table \"Person\" (\nid int primary key,\nname text\n);\n\ncreate table \"Address\"(\nid int primary key,\n\"isPrimary\" bool not null default false,\n\"personId\" int references \"Person\"(id),\naddress text\n);\n\n-- Example computed relation\ncreate function \"primaryAddress\"(\"Person\")\nreturns setof \"Address\" rows 1\nlanguage sql\nas\n$$\nselect addr\nfrom \"Address\" addr\nwhere $1.id = addr.\"personId\"\nand addr.\"isPrimary\"\nlimit 1\n$$;\n\ninsert into \"Person\"(id, name)\nvalues (1, 'Foo Barington');\n\ninsert into \"Address\"(id, \"isPrimary\", \"personId\", address)\nvalues (4, true, 1, '1 Main St.');\n</code></pre></p> <p>results in the GraphQL type</p> Person <pre><code>type Person implements Node {\n  \"\"\"Globally Unique Record Identifier\"\"\"\n  nodeId: ID!\n  ...\n  primaryAddress: Address\n}\n</code></pre> <p>and can be queried like a natively enforced relationship</p> QueryResponse <pre><code>{\n  personCollection {\n    edges {\n      node {\n        id\n        name\n        primaryAddress {\n          address\n        }\n      }\n    }\n\n  }\n}\n</code></pre> <pre><code>{\n\"data\": {\n\"personCollection\": {\n\"edges\": [\n{\n\"node\": {\n\"id\": 1,\n\"name\": \"Foo Barington\",\n\"primaryAddress\": {\n\"address\": \"1 Main St.\"\n}\n}\n}\n]\n}\n}\n}\n</code></pre>"},{"location":"computed_fields/#to-many","title":"To-Many","text":"<p>To-many relationships can be defined using a function that returns a <code>setof &lt;entity&gt;</code></p> <p>For example: <pre><code>create table \"Person\" (\nid int primary key,\nname text\n);\n\ncreate table \"Address\"(\nid int primary key,\naddress text\n);\n\ncreate table \"PersonAtAddress\"(\nid int primary key,\n\"personId\" int not null,\n\"addressId\" int not null\n);\n\n\n-- Computed relation to bypass \"PersonAtAddress\" table for cleaner API\ncreate function \"addresses\"(\"Person\")\nreturns setof \"Address\"\nlanguage sql\nas\n$$\nselect\naddr\nfrom\n\"PersonAtAddress\" pa\njoin \"Address\" addr\non pa.\"addressId\" = \"addr\".id\nwhere\npa.\"personId\" = $1.id\n$$;\n\ninsert into \"Person\"(id, name)\nvalues (1, 'Foo Barington');\n\ninsert into \"Address\"(id, address)\nvalues (4, '1 Main St.');\n\ninsert into \"PersonAtAddress\"(id, \"personId\", \"addressId\")\nvalues (2, 1, 4);\n</code></pre></p> <p>results in the GraphQL type</p> Person <pre><code>type Person implements Node {\n  \"\"\"Globally Unique Record Identifier\"\"\"\n  nodeId: ID!\n  ...\n  addresses(\n    first: Int\n    last: Int\n    before: Cursor\n    after: Cursor\n    filter: AddressFilter\n    orderBy: [AddressOrderBy!]\n  ): AddressConnection\n}\n</code></pre> <p>and can be queried like a natively enforced relationship</p> QueryResponse <pre><code>{\n  personCollection {\n    edges {\n      node {\n        id\n        name\n        addresses {\n          edges {\n            node {\n              id\n              address\n            }\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n\"data\": {\n\"personCollection\": {\n\"edges\": [\n{\n\"node\": {\n\"id\": 1,\n\"name\": \"Foo Barington\",\n\"addresses\": {\n\"edges\": [\n{\n\"node\": {\n\"id\": 4,\n\"address\": \"1 Main St.\"\n}\n}\n]\n}\n}\n}\n]\n}\n}\n}\n</code></pre>"},{"location":"configuration/","title":"Configuration","text":"<p>Extra configuration options can be set on SQL entities using comment directives.</p>"},{"location":"configuration/#comment-directives","title":"Comment Directives","text":"<p>Comment directives are snippets of configuration associated with SQL entities that alter how those entities behave.</p> <p>The format of a comment directive is</p> <pre><code>@graphql(&lt;JSON&gt;)\n</code></pre>"},{"location":"configuration/#inflection","title":"Inflection","text":"<p>Inflection describes how SQL entities' names are transformed into GraphQL type and field names. By default, inflection is disabled and SQL names are literally interpolated such that</p> <pre><code>create table \"BlogPost\"(\nid int primary key,\n...\n);\n</code></pre> <p>results in GraphQL type names like <pre><code>BlogPost\nBlogPostEdge\nBlogPostConnection\n...\n</code></pre></p> <p>Since snake case is a common casing structure for SQL types, <code>pg_graphql</code> support basic inflection from <code>snake_case</code> to <code>PascalCase</code> for type names, and <code>snake_case</code> to <code>camelCase</code> for field names to match Javascript conventions.</p> <p>The inflection directive can be applied at the schema level with:</p> <pre><code>comment on schema &lt;schema_name&gt; is e'@graphql({\"inflect_names\": true})';\n</code></pre> <p>for example <pre><code>comment on schema public is e'@graphql({\"inflect_names\": true})';\n\ncreate table blog_post(\nid int primary key,\n...\n);\n</code></pre></p> <p>similarly would generated the GraphQL type names <pre><code>BlogPost\nBlogPostEdge\nBlogPostConnection\n...\n</code></pre></p> <p>For more fine grained adjustments to reflected names, see renaming.</p>"},{"location":"configuration/#max-rows","title":"Max Rows","text":"<p>The default page size for collections is 30 entries. To adjust the number of entries on each page, set a <code>max_rows</code> directive on the relevant schema entity.</p> <p>For example, to increase the max rows per page for each table in the <code>public</code> schema: <pre><code>comment on schema public is e'@graphql({\"max_rows\": 100})';\n</code></pre></p>"},{"location":"configuration/#totalcount","title":"totalCount","text":"<p><code>totalCount</code> is an opt-in field that extends a table's Connection type. It provides a count of the rows that match the query's filters, and ignores pagination arguments.</p> <pre><code>type BlogPostConnection {\n  edges: [BlogPostEdge!]!\n  pageInfo: PageInfo!\n\n  \"\"\"The total number of records matching the `filter` criteria\"\"\"\n  totalCount: Int! # this field\n}\n</code></pre> <p>to enable <code>totalCount</code> for a table, use the directive</p> <p><pre><code>comment on table \"BlogPost\" is e'@graphql({\"totalCount\": {\"enabled\": true}})';\n</code></pre> for example <pre><code>create table \"BlogPost\"(\nid serial primary key,\nemail varchar(255) not null\n);\ncomment on table \"BlogPost\" is e'@graphql({\"totalCount\": {\"enabled\": true}})';\n</code></pre></p>"},{"location":"configuration/#renaming","title":"Renaming","text":""},{"location":"configuration/#tables-type","title":"Table's Type","text":"<p>Use the <code>\"name\"</code> JSON key to override a table's type name.</p> <pre><code>create table account(\nid serial primary key\n);\n\ncomment on table public.account is\ne'@graphql({\"name\": \"AccountHolder\"})';\n</code></pre> <p>results in: <pre><code>type AccountHolder { # previously: \"Account\"\n  id: Int!\n}\n</code></pre></p>"},{"location":"configuration/#columns-field-name","title":"Column's Field Name","text":"<p>Use the <code>\"name\"</code> JSON key to override a column's field name.</p> <pre><code>create table public.\"Account\"(\nid serial primary key,\nemail text\n);\n\ncomment on column \"Account\".email is\ne'@graphql({\"name\": \"emailAddress\"})';\n</code></pre> <p>results in: <pre><code>type Account {\n  nodeId: ID!\n  id: Int!\n  emailAddress: String! # previously \"email\"\n}\n</code></pre></p>"},{"location":"configuration/#computed-field","title":"Computed Field","text":"<p>Use the <code>\"name\"</code> JSON key to override a computed field's name.</p> <pre><code>create table \"Account\"(\nid serial primary key,\n\"firstName\" varchar(255) not null,\n\"lastName\" varchar(255) not null\n);\n\n-- Extend with function\ncreate function public.\"_fullName\"(rec public.\"Account\")\nreturns text\nimmutable\nstrict\nlanguage sql\nas $$\nselect format('%s %s', rec.\"firstName\", rec.\"lastName\")\n$$;\n\ncomment on function public._full_name is\ne'@graphql({\"name\": \"displayName\"})';\n</code></pre> <p>results in: <pre><code>type Account {\n  nodeId: ID!\n  id: Int!\n  firstName: String!\n  lastName: String!\n  displayName: String # previously \"fullName\"\n}\n</code></pre></p>"},{"location":"configuration/#relationships-field","title":"Relationship's Field","text":"<p>Use the <code>\"local_name\"</code> and <code>\"foreign_name\"</code> JSON keys to override a a relationships inbound and outbound field names.</p> <pre><code>create table \"Account\"(\nid serial primary key\n);\n\ncreate table \"Post\"(\nid serial primary key,\n\"accountId\" integer not null references \"Account\"(id),\ntitle text not null,\nbody text\n);\n\ncomment on constraint post_owner_id_fkey\non \"Post\"\nis E'@graphql({\"foreign_name\": \"author\", \"local_name\": \"posts\"})';\n</code></pre> <p>results in: <pre><code>type Post {\n  nodeId: ID!\n  id: Int!\n  accountId: Int!\n  title: String!\n  body: String!\n  author: Account # was \"account\"\n}\n\ntype Account {\n  id: Int!\n  posts( # was \"postCollection\"\n    after: Cursor,\n    before: Cursor,\n    filter: PostFilter,\n    first: Int,\n    last: Int,\n    orderBy: [PostOrderBy!]\n  ): PostConnection\n}\n</code></pre></p>"},{"location":"configuration/#description","title":"Description","text":"<p>Tables, Columns, and Functions accept a <code>description</code> directive to populate user defined descriptions in the GraphQL schema.</p> <pre><code>create table \"Account\"(\nid serial primary key\n);\n\ncomment on table public.account\nis e'@graphql({\"description\": \"A User Account\"})';\n\ncomment on column public.account.id\nis e'@graphql({\"description\": \"The primary key identifier\"})';\n</code></pre> <pre><code>\"\"\"A User Account\"\"\"\ntype Account implements Node {\n\n  \"\"\"The primary key identifier\"\"\"\n  id: Int!\n}\n</code></pre>"},{"location":"configuration/#enum-variant","title":"Enum Variant","text":"<p>If a variant of a Postgres enum does not conform to GraphQL naming conventions, introspection returns an error:</p> <p>For example: <pre><code>create type \"Algorithm\" as enum ('aead-ietf');\n</code></pre></p> <p>causes the error:</p> <pre><code>{\n\"errors\": [\n{\n\"message\": \"Names must only contain [_a-zA-Z0-9] but \\\"aead-ietf\\\" does not.\",\n}\n]\n}\n</code></pre> <p>To resolve this problem, rename the invalid SQL enum variant to a GraphQL compatible name:</p> <pre><code>alter type \"Algorithm\" rename value 'aead-ietf' to 'AEAD_IETF';\n</code></pre> <p>or, add a comment directive to remap the enum variant in the GraphQL API</p> <pre><code>comment on type \"Algorithm\" is '@graphql({\"mappings\": {\"aead-ietf\": \"AEAD_IETF\"}})';\n</code></pre> <p>Which both result in the GraphQL enum: <pre><code>enum Algorithm {\n  AEAD_IETF\n}\n</code></pre></p>"},{"location":"contributing/","title":"Contributing","text":"<p>pg_graphql is OSS. PR and issues are welcome.</p>"},{"location":"contributing/#development","title":"Development","text":"<p>Requirements:</p> <ul> <li>rust</li> <li>cargo</li> <li>pgrx</li> </ul>"},{"location":"contributing/#testing","title":"Testing","text":"<p>Tests are located in <code>./test/sql</code> with expected output in <code>./test/expected</code></p> <p>To run tests locally, execute:</p> <pre><code>$ cargo pgrx install; ./bin/installcheck\n</code></pre>"},{"location":"contributing/#interactive-psql-development","title":"Interactive PSQL Development","text":"<p>To reduce the iteration cycle, you may want to launch a psql prompt with <code>pg_graphql</code> installed to experiment</p> <pre><code>cargo pgrx run pg14\n</code></pre> <p>Try out the commands below to spin up a database with the extension installed &amp; query a table using GraphQL. Experiment with aliasing field/table names and filtering on different columns.</p> <pre><code>graphqldb= create extension pg_graphql cascade;\nCREATE EXTENSION\n\ngraphqldb= create table book(id int primary key, title text);\nCREATE TABLE\n\ngraphqldb= insert into book(id, title) values (1, 'book 1');\nINSERT 0 1\n</code></pre> <p>Finally, execute some graphql queries against the table. <pre><code>graphqldb= select graphql.resolve($$\nquery {\nbookCollection {\nedges {\nnode {\nid\n}\n}\n}\n}\n$$);\n\nresolve\n----------------------------------------------------------------------\n{\"data\": {\"bookCollection\": {\"edges\": [{\"node\": {\"id\": 1}}]}}, \"errors\": []}\n</code></pre></p>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>All public API must be documented. Building documentation requires python 3.6+</p>"},{"location":"contributing/#install-dependencies","title":"Install Dependencies","text":"<p>Install mkdocs, themes, and extensions.</p> <pre><code>pip install -r docs/requirements_docs.txt\n</code></pre>"},{"location":"contributing/#serving","title":"Serving","text":"<p>To serve the documentation locally run</p> <pre><code>mkdocs serve\n</code></pre> <p>and visit the docs at http://127.0.0.1:8000/pg_graphql/</p>"},{"location":"example_schema/","title":"Example Schema","text":"<p>The following is a complete example showing how a sample SQL schema translates into a GraphQL schema.</p> <pre><code>-- Turn on automatic inflection of type names\ncomment on schema public is '@graphql({\"inflect_names\": true})';\n\ncreate table account(\nid serial primary key,\nemail varchar(255) not null,\ncreated_at timestamp not null,\nupdated_at timestamp not null\n);\n\n-- enable a `totalCount` field on the `account` query type\ncomment on table account is e'@graphql({\"totalCount\": {\"enabled\": true}})';\n\ncreate table blog(\nid serial primary key,\nowner_id integer not null references account(id),\nname varchar(255) not null,\ndescription varchar(255),\ncreated_at timestamp not null,\nupdated_at timestamp not null\n);\n\ncreate type blog_post_status as enum ('PENDING', 'RELEASED');\n\ncreate table blog_post(\nid uuid not null default uuid_generate_v4() primary key,\nblog_id integer not null references blog(id),\ntitle varchar(255) not null,\nbody varchar(10000),\nstatus blog_post_status not null,\ncreated_at timestamp not null,\nupdated_at timestamp not null\n);\n</code></pre> <pre><code>type Account implements Node {\n  \"\"\"Globally Unique Record Identifier\"\"\"\n  nodeId: ID!\n  id: Int!\n  email: String!\n  createdAt: Datetime!\n  blogCollection(\n    \"\"\"Query the first `n` records in the collection\"\"\"\n    first: Int\n\n    \"\"\"Query the last `n` records in the collection\"\"\"\n    last: Int\n\n    \"\"\"Query values in the collection before the provided cursor\"\"\"\n    before: Cursor\n\n    \"\"\"Query values in the collection after the provided cursor\"\"\"\n    after: Cursor\n\n    \"\"\"Filters to apply to the results set when querying from the collection\"\"\"\n    filter: BlogFilter\n\n    \"\"\"Sort order to apply to the collection\"\"\"\n    orderBy: [BlogOrderBy!]\n  ): BlogConnection\n}\n\ntype AccountConnection {\n  edges: [AccountEdge!]!\n  pageInfo: PageInfo!\n}\n\ntype AccountDeleteResponse {\n  \"\"\"Count of the records impacted by the mutation\"\"\"\n  affectedCount: Int!\n\n  \"\"\"Array of records impacted by the mutation\"\"\"\n  records: [Account!]!\n}\n\ntype AccountEdge {\n  cursor: String!\n  node: Account!\n}\n\ninput AccountFilter {\n  nodeId: IDFilter\n  id: IntFilter\n  email: StringFilter\n  createdAt: DatetimeFilter\n  and: [AccountFilter!]\n  or: [AccountFilter!]\n  not: AccountFilter\n}\n\ninput AccountInsertInput {\n  email: String\n  createdAt: Datetime\n}\n\ntype AccountInsertResponse {\n  \"\"\"Count of the records impacted by the mutation\"\"\"\n  affectedCount: Int!\n\n  \"\"\"Array of records impacted by the mutation\"\"\"\n  records: [Account!]!\n}\n\ninput AccountOrderBy {\n  id: OrderByDirection\n  email: OrderByDirection\n  createdAt: OrderByDirection\n}\n\ninput AccountUpdateInput {\n  email: String\n  createdAt: Datetime\n}\n\ntype AccountUpdateResponse {\n  \"\"\"Count of the records impacted by the mutation\"\"\"\n  affectedCount: Int!\n\n  \"\"\"Array of records impacted by the mutation\"\"\"\n  records: [Account!]!\n}\n\ntype Blog implements Node {\n  \"\"\"Globally Unique Record Identifier\"\"\"\n  nodeId: ID!\n  id: Int!\n  ownerId: Int!\n  name: String!\n  description: String\n  createdAt: Datetime!\n  owner: Account\n  blogPostCollection(\n    \"\"\"Query the first `n` records in the collection\"\"\"\n    first: Int\n\n    \"\"\"Query the last `n` records in the collection\"\"\"\n    last: Int\n\n    \"\"\"Query values in the collection before the provided cursor\"\"\"\n    before: Cursor\n\n    \"\"\"Query values in the collection after the provided cursor\"\"\"\n    after: Cursor\n\n    \"\"\"Filters to apply to the results set when querying from the collection\"\"\"\n    filter: BlogPostFilter\n\n    \"\"\"Sort order to apply to the collection\"\"\"\n    orderBy: [BlogPostOrderBy!]\n  ): BlogPostConnection\n}\n\ntype BlogConnection {\n  edges: [BlogEdge!]!\n  pageInfo: PageInfo!\n}\n\ntype BlogDeleteResponse {\n  \"\"\"Count of the records impacted by the mutation\"\"\"\n  affectedCount: Int!\n\n  \"\"\"Array of records impacted by the mutation\"\"\"\n  records: [Blog!]!\n}\n\ntype BlogEdge {\n  cursor: String!\n  node: Blog!\n}\n\ninput BlogFilter {\n  nodeId: IDFilter\n  id: IntFilter\n  ownerId: IntFilter\n  name: StringFilter\n  description: StringFilter\n  createdAt: DatetimeFilter\n  and: [BlogFilter!]\n  or: [BlogFilter!]\n  not: BlogFilter\n}\n\ninput BlogInsertInput {\n  ownerId: Int\n  name: String\n  description: String\n  createdAt: Datetime\n}\n\ntype BlogInsertResponse {\n  \"\"\"Count of the records impacted by the mutation\"\"\"\n  affectedCount: Int!\n\n  \"\"\"Array of records impacted by the mutation\"\"\"\n  records: [Blog!]!\n}\n\ninput BlogOrderBy {\n  id: OrderByDirection\n  ownerId: OrderByDirection\n  name: OrderByDirection\n  description: OrderByDirection\n  createdAt: OrderByDirection\n}\n\ntype BlogPost implements Node {\n  \"\"\"Globally Unique Record Identifier\"\"\"\n  nodeId: ID!\n  id: UUID!\n  blogId: Int!\n  title: String!\n  body: String\n  status: BlogPostStatus!\n  createdAt: Datetime!\n  blog: Blog\n}\n\ntype BlogPostConnection {\n  edges: [BlogPostEdge!]!\n  pageInfo: PageInfo!\n}\n\ntype BlogPostDeleteResponse {\n  \"\"\"Count of the records impacted by the mutation\"\"\"\n  affectedCount: Int!\n\n  \"\"\"Array of records impacted by the mutation\"\"\"\n  records: [BlogPost!]!\n}\n\ntype BlogPostEdge {\n  cursor: String!\n  node: BlogPost!\n}\n\ninput BlogPostFilter {\n  nodeId: IDFilter\n  id: UUIDFilter\n  blogId: IntFilter\n  title: StringFilter\n  body: StringFilter\n  status: BlogPostStatusFilter\n  createdAt: DatetimeFilter\n  and: [BlogPostFilter!]\n  or: [BlogPostFilter!]\n  not: BlogPostFilter\n}\n\ninput BlogPostInsertInput {\n  id: UUID\n  blogId: Int\n  title: String\n  body: String\n  status: BlogPostStatus\n  createdAt: Datetime\n}\n\ntype BlogPostInsertResponse {\n  \"\"\"Count of the records impacted by the mutation\"\"\"\n  affectedCount: Int!\n\n  \"\"\"Array of records impacted by the mutation\"\"\"\n  records: [BlogPost!]!\n}\n\ninput BlogPostOrderBy {\n  id: OrderByDirection\n  blogId: OrderByDirection\n  title: OrderByDirection\n  body: OrderByDirection\n  status: OrderByDirection\n  createdAt: OrderByDirection\n}\n\nenum FilterIs {\n  PENDING\n  RELEASED\n}\n\nenum BlogPostStatus {\n  PENDING\n  RELEASED\n}\n\n\"\"\"\nBoolean expression comparing fields on type \"BlogPostStatus\"\n\"\"\"\ninput BlogPostStatusFilter {\n  eq: BlogPostStatus\n  in: [BlogPostStatus!]\n  neq: BlogPostStatus\n  is: FilterIs\n}\n\ninput BlogPostUpdateInput {\n  id: UUID\n  blogId: Int\n  title: String\n  body: String\n  status: BlogPostStatus\n  createdAt: Datetime\n}\n\ntype BlogPostUpdateResponse {\n  \"\"\"Count of the records impacted by the mutation\"\"\"\n  affectedCount: Int!\n\n  \"\"\"Array of records impacted by the mutation\"\"\"\n  records: [BlogPost!]!\n}\n\ninput BlogUpdateInput {\n  ownerId: Int\n  name: String\n  description: String\n  createdAt: Datetime\n}\n\ntype BlogUpdateResponse {\n  \"\"\"Count of the records impacted by the mutation\"\"\"\n  affectedCount: Int!\n\n  \"\"\"Array of records impacted by the mutation\"\"\"\n  records: [Blog!]!\n}\n\n\"\"\"\nBoolean expression comparing fields on type \"ID\"\n\"\"\"\ninput IDFilter {\n  eq: ID\n}\n\nscalar BigInt\n\n\"\"\"\nBoolean expression comparing fields on type \"BigInt\"\n\"\"\"\ninput BigIntFilter {\n  eq: BigInt\n  gt: BigInt\n  gte: BigInt\n  in: [BigInt!]\n  lt: BigInt\n  lte: BigInt\n  neq: BigInt\n  is: FilterIs\n}\n\nscalar BigFloat\n\n\"\"\"\nBoolean expression comparing fields on type \"BigInt\"\n\"\"\"\ninput BigFloatFilter {\n  eq: BigFloat\n  gt: BigFloat\n  gte: BigFloat\n  in: [BigFloat!]\n  lt: BigFloat\n  lte: BigFloat\n  neq: BigFloat\n  is: FilterIs\n}\n\n\n\"\"\"\nBoolean expression comparing fields on type \"Boolean\"\n\"\"\"\ninput BooleanFilter {\n  eq: Boolean\n  is: FilterIs\n}\n\nscalar Opaque\n\n\"\"\"\nBoolean expression comparing fields on type \"Opaque\"\n\"\"\"\ninput OpaqueFilter {\n  eq: Opaque\n  is: FilterIs\n}\n\nscalar Cursor\n\nscalar Date\n\n\"\"\"\nBoolean expression comparing fields on type \"Date\"\n\"\"\"\ninput DateFilter {\n  eq: Date\n  gt: Date\n  gte: Date\n  in: [Date!]\n  lt: Date\n  lte: Date\n  neq: Date\n  is: FilterIs\n}\n\nscalar Datetime\n\n\"\"\"\nBoolean expression comparing fields on type \"Datetime\"\n\"\"\"\ninput DatetimeFilter {\n  eq: Datetime\n  gt: Datetime\n  gte: Datetime\n  in: [Datetime!]\n  lt: Datetime\n  lte: Datetime\n  neq: Datetime\n  is: FilterIs\n}\n\n\"\"\"\nBoolean expression comparing fields on type \"Float\"\n\"\"\"\ninput FloatFilter {\n  eq: Float\n  gt: Float\n  gte: Float\n  in: [Float!]\n  lt: Float\n  lte: Float\n  neq: Float\n  is: FilterIs\n}\n\n\"\"\"\nBoolean expression comparing fields on type \"Int\"\n\"\"\"\ninput IntFilter {\n  eq: Int\n  gt: Int\n  gte: Int\n  in: [Int!]\n  lt: Int\n  lte: Int\n  neq: Int\n  is: FilterIs\n}\n\nscalar JSON\n\n\"\"\"The root type for creating and mutating data\"\"\"\ntype Mutation {\n  \"\"\"Deletes zero or more records from the `Account` collection\"\"\"\n  deleteFromAccountCollection(\n    \"\"\"Restricts the mutation's impact to records matching the criteria\"\"\"\n    filter: AccountFilter\n\n    \"\"\"\n    The maximum number of records in the collection permitted to be affected\n    \"\"\"\n    atMost: Int! = 1\n  ): AccountDeleteResponse!\n\n  \"\"\"Deletes zero or more records from the `Blog` collection\"\"\"\n  deleteFromBlogCollection(\n    \"\"\"Restricts the mutation's impact to records matching the criteria\"\"\"\n    filter: BlogFilter\n\n    \"\"\"\n    The maximum number of records in the collection permitted to be affected\n    \"\"\"\n    atMost: Int! = 1\n  ): BlogDeleteResponse!\n\n  \"\"\"Deletes zero or more records from the `BlogPost` collection\"\"\"\n  deleteFromBlogPostCollection(\n    \"\"\"Restricts the mutation's impact to records matching the criteria\"\"\"\n    filter: BlogPostFilter\n\n    \"\"\"\n    The maximum number of records in the collection permitted to be affected\n    \"\"\"\n    atMost: Int! = 1\n  ): BlogPostDeleteResponse!\n\n  \"\"\"Adds one or more `Account` records to the collection\"\"\"\n  insertIntoAccountCollection(objects: [AccountInsertInput!]!): AccountInsertResponse\n\n  \"\"\"Adds one or more `Blog` records to the collection\"\"\"\n  insertIntoBlogCollection(objects: [BlogInsertInput!]!): BlogInsertResponse\n\n  \"\"\"Adds one or more `BlogPost` records to the collection\"\"\"\n  insertIntoBlogPostCollection(objects: [BlogPostInsertInput!]!): BlogPostInsertResponse\n\n  \"\"\"Updates zero or more records in the `Account` collection\"\"\"\n  updateAccountCollection(\n    \"\"\"\n    Fields that are set will be updated for all records matching the `filter`\n    \"\"\"\n    set: AccountUpdateInput!\n\n    \"\"\"Restricts the mutation's impact to records matching the criteria\"\"\"\n    filter: AccountFilter\n\n    \"\"\"\n    The maximum number of records in the collection permitted to be affected\n    \"\"\"\n    atMost: Int! = 1\n  ): AccountUpdateResponse!\n\n  \"\"\"Updates zero or more records in the `Blog` collection\"\"\"\n  updateBlogCollection(\n    \"\"\"\n    Fields that are set will be updated for all records matching the `filter`\n    \"\"\"\n    set: BlogUpdateInput!\n\n    \"\"\"Restricts the mutation's impact to records matching the criteria\"\"\"\n    filter: BlogFilter\n\n    \"\"\"\n    The maximum number of records in the collection permitted to be affected\n    \"\"\"\n    atMost: Int! = 1\n  ): BlogUpdateResponse!\n\n  \"\"\"Updates zero or more records in the `BlogPost` collection\"\"\"\n  updateBlogPostCollection(\n    \"\"\"\n    Fields that are set will be updated for all records matching the `filter`\n    \"\"\"\n    set: BlogPostUpdateInput!\n\n    \"\"\"Restricts the mutation's impact to records matching the criteria\"\"\"\n    filter: BlogPostFilter\n\n    \"\"\"\n    The maximum number of records in the collection permitted to be affected\n    \"\"\"\n    atMost: Int! = 1\n  ): BlogPostUpdateResponse!\n}\n\ninterface Node {\n  \"\"\"Retrieves a record by `ID`\"\"\"\n  nodeId: ID!\n}\n\n\"\"\"Defines a per-field sorting order\"\"\"\nenum OrderByDirection {\n  \"\"\"Ascending order, nulls first\"\"\"\n  AscNullsFirst\n\n  \"\"\"Ascending order, nulls last\"\"\"\n  AscNullsLast\n\n  \"\"\"Descending order, nulls first\"\"\"\n  DescNullsFirst\n\n  \"\"\"Descending order, nulls last\"\"\"\n  DescNullsLast\n}\n\ntype PageInfo {\n  endCursor: String\n  hasNextPage: Boolean!\n  hasPreviousPage: Boolean!\n  startCursor: String\n}\n\n\"\"\"The root type for querying data\"\"\"\ntype Query {\n  \"\"\"A pagable collection of type `Account`\"\"\"\n  accountCollection(\n    \"\"\"Query the first `n` records in the collection\"\"\"\n    first: Int\n\n    \"\"\"Query the last `n` records in the collection\"\"\"\n    last: Int\n\n    \"\"\"Query values in the collection before the provided cursor\"\"\"\n    before: Cursor\n\n    \"\"\"Query values in the collection after the provided cursor\"\"\"\n    after: Cursor\n\n    \"\"\"Filters to apply to the results set when querying from the collection\"\"\"\n    filter: AccountFilter\n\n    \"\"\"Sort order to apply to the collection\"\"\"\n    orderBy: [AccountOrderBy!]\n  ): AccountConnection\n\n  \"\"\"A pagable collection of type `Blog`\"\"\"\n  blogCollection(\n    \"\"\"Query the first `n` records in the collection\"\"\"\n    first: Int\n\n    \"\"\"Query the last `n` records in the collection\"\"\"\n    last: Int\n\n    \"\"\"Query values in the collection before the provided cursor\"\"\"\n    before: Cursor\n\n    \"\"\"Query values in the collection after the provided cursor\"\"\"\n    after: Cursor\n\n    \"\"\"Filters to apply to the results set when querying from the collection\"\"\"\n    filter: BlogFilter\n\n    \"\"\"Sort order to apply to the collection\"\"\"\n    orderBy: [BlogOrderBy!]\n  ): BlogConnection\n\n  \"\"\"A pagable collection of type `BlogPost`\"\"\"\n  blogPostCollection(\n    \"\"\"Query the first `n` records in the collection\"\"\"\n    first: Int\n\n    \"\"\"Query the last `n` records in the collection\"\"\"\n    last: Int\n\n    \"\"\"Query values in the collection before the provided cursor\"\"\"\n    before: Cursor\n\n    \"\"\"Query values in the collection after the provided cursor\"\"\"\n    after: Cursor\n\n    \"\"\"Filters to apply to the results set when querying from the collection\"\"\"\n    filter: BlogPostFilter\n\n    \"\"\"Sort order to apply to the collection\"\"\"\n    orderBy: [BlogPostOrderBy!]\n  ): BlogPostConnection\n\n  \"\"\"Retrieve a record by its `ID`\"\"\"\n  node(\n    \"\"\"The record's `ID`\"\"\"\n    nodeId: ID!\n  ): Node\n}\n\n\"\"\"\nBoolean expression comparing fields on type \"String\"\n\"\"\"\ninput StringFilter {\n  eq: String\n  gt: String\n  gte: String\n  in: [String!]\n  lt: String\n  lte: String\n  neq: String\n  is: FilterIs\n  startsWith: String\n  like: String\n  ilike: String\n  regex: String\n  iregex: String\n}\n\nscalar Time\n\n\"\"\"\nBoolean expression comparing fields on type \"Time\"\n\"\"\"\ninput TimeFilter {\n  eq: Time\n  gt: Time\n  gte: Time\n  in: [Time!]\n  lt: Time\n  lte: Time\n  neq: Time\n  is: FilterIs\n}\n\nscalar UUID\n\n\"\"\"\nBoolean expression comparing fields on type \"UUID\"\n\"\"\"\ninput UUIDFilter {\n  eq: UUID\n  in: [UUID!]\n  neq: UUID\n  is: FilterIs\n}\n</code></pre>"},{"location":"installation/","title":"Installation","text":"<p>First, install pgrx by running <code>cargo install --locked cargo-pgrx@version</code>, where version should be compatible with the pgrx version used by pg_graphl</p> <p>Then clone the repo and install using</p> <pre><code>git clone https://github.com/supabase/pg_graphql.git\ncd pg_graphql\ncargo pgrx install --release\n</code></pre> <p>To enable the extension in PostgreSQL we must execute a <code>create extension</code> statement. The extension creates its own schema/namespace named <code>graphql</code> to avoid naming conflicts.</p> <pre><code>create extension pg_graphql;\n</code></pre>"},{"location":"quickstart/","title":"Quickstart","text":"<p>If you are new to the project, start here.</p> <p>The easiest way to try <code>pg_graphql</code> is to run the interactive GraphiQL IDE demo. The demo environment launches a database, webserver and the GraphiQL IDE/API explorer with a small pre-populated schema.</p> <p>Requires:</p> <ul> <li>git</li> <li>docker-compose</li> </ul> <p>First, clone the repo</p> <pre><code>git clone https://github.com/supabase/pg_graphql.git\ncd pg_graphql\n</code></pre> <p>Next, launch the demo with docker-compose.</p> <pre><code>docker-compose up\n</code></pre> <p>Finally, access GraphiQL at <code>http://localhost:4000/</code>.</p> <p></p>"},{"location":"security/","title":"Security","text":"<p><code>pg_graphql</code> fully respects builtin PostgreSQL role and row security.</p>"},{"location":"security/#tablecolumn-visibility","title":"Table/Column Visibility","text":"<p>Table and column visibility in the GraphQL schema are controlled by standard PostgreSQL role permissions. Revoking <code>SELECT</code> access from the user/role executing queries removes that entity from the visible schema.</p> <p>For example: <pre><code>revoke all privileges on public.\"Account\" from api_user;\n</code></pre></p> <p>removes the <code>Account</code> GraphQL type.</p> <p>Similarly, revoking <code>SELECT</code> access on a table's column will remove that field from the associated GraphQL type/s.</p> <p>The permissions <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> all impact the relevant sections of the GraphQL schema.</p>"},{"location":"security/#row-visibility","title":"Row Visibility","text":"<p>Visibility of rows in a given table can be configured using PostgreSQL's built-in row level security policies.</p>"},{"location":"sql_interface/","title":"SQL Interface","text":"<p>pg_graphql's public facing SQL interface consists of a single SQL function to resolve GraphQL requests. All other entities in the <code>graphql</code> schema are private.</p>"},{"location":"sql_interface/#graphqlresolve","title":"graphql.resolve","text":""},{"location":"sql_interface/#description","title":"description","text":"<p>Resolves a GraphQL query, returning JSONB.</p>"},{"location":"sql_interface/#signature","title":"signature","text":"<pre><code>graphql.resolve(\n-- graphql query/mutation\nquery text,\n-- json key/values pairs for variables\nvariables jsonb default '{}'::jsonb,\n-- the name of the graphql operation in *query* to execute\n\"operationName\" text default null,\n-- extensions to include in the request\nextensions jsonb default null,\n)\nreturns jsonb\n\nstrict\nvolatile\nparallel safe\nlanguage plpgsql\n</code></pre>"},{"location":"sql_interface/#usage","title":"usage","text":"<pre><code>-- Create the extension\ngraphqldb= create extension pg_graphql;\nCREATE EXTENSION\n\n-- Create an example table\ngraphqldb= create table book(id int primary key, title text);\nCREATE TABLE\n\n-- Insert a record\ngraphqldb= insert into book(id, title) values (1, 'book 1');\nINSERT 0 1\n\n-- Query the table via GraphQL\ngraphqldb= select graphql.resolve($$\nquery {\nbookCollection {\nedges {\nnode {\nid\n}\n}\n}\n}\n$$);\n\nresolve\n----------------------------------------------------------------------\n{\"data\": {\"bookCollection\": {\"edges\": [{\"node\": {\"id\": 1}}]}}, \"errors\": []}\n</code></pre>"},{"location":"supabase/","title":"Supabase","text":"<p>The Supabase GraphQL API is automatically reflected from your database's schema using pg_graphql. It supports:</p> <ul> <li>Basic CRUD operations (Create/Read/Update/Delete)</li> <li>Support for Tables, Views, Materialized Views, and Foreign Tables</li> <li>Arbitrarily deep relationships among tables/views</li> <li>User defined computed fields</li> <li>Postgres' security model - including Row Level Security, Roles, and Grants</li> </ul> <p>All requests resolve in a single round-trip leading to fast response times and high throughput.</p> <p>If you haven't created a Supabase project, do that here so you can follow along with the guide.</p>"},{"location":"supabase/#clients","title":"Clients","text":"<p>If you're new to GraphQL or Supabase, we strongly recommend starting with Supabase GraphQL by following the Supabase Studio guide.</p> <p>Fore more experienced users, or when you're ready to productionize your application, access the API using supabase-js, GraphiQL, or any HTTP client, for example cURL.</p>"},{"location":"supabase/#supabase-studio","title":"Supabase Studio","text":"<p>The easiest way to make a GraphQL request with Supabase is to use Supabase Studio's builtin GraphiQL IDE. You can access GraphiQL here by selecting the relevant project. Alternatively, navigate there within Studio at <code>API Docs &gt; GraphQL &gt; GraphiQL</code>.</p> <p></p> <p>Type queries in the central query editor and use the green icon to submit requests to the server. Results are shown in the output display to the right of the editor.</p> <p>To explore the API visually, select the docs icon shown below and navigate through each type to see how they connect to the Graph.</p> <p></p> <p>pg_graphql mirrors the structure of the project's SQL schema in the GraphQL API. If your project is new and empty, the GraphQL API will be empty as well, with the exception of basic introspection types. For a more interesting result, go to the SQL or table editor and create a table.</p> <p></p> <p>Head back to GraphiQL to see the new table reflected in your GraphQL API's Query and Mutation types.</p> <p></p> <p>If you'd like your type and field names to match the GraphQL convention of <code>PascalCase</code> for types and <code>camelCase</code> for fields, check out the pg_graphql inflection guide.</p>"},{"location":"supabase/#http-request","title":"HTTP Request","text":"<p>To access the GraphQL API over HTTP, first collect your project reference and API Key.</p>"},{"location":"supabase/#curl","title":"cURL","text":"<p>To hit the Supabase GraphQL API using cURL, submit a <code>POST</code> request to your GraphQL API's URL shown below, substituting in your PROJECT_REF and passing the project's API_KEY as the <code>apiKey</code> header:</p> <pre><code>curl -X POST https://&lt;PROJECT_REF&gt;.supabase.co/graphql/v1 \\\n-H 'apiKey: &lt;API_KEY&gt;' \\\n-H 'Content-Type: application/json' \\\n--data-raw '{\"query\": \"{ accountCollection(first: 1) { edges { node { id } } } }\", \"variables\": {}}'\n</code></pre> <p>In that example, the GraphQL <code>query</code> is <pre><code>{\n  accountCollection(first: 1) {\n    edges {\n      node {\n        id\n      }\n    }\n  }\n}\n</code></pre></p> <p>and there are no <code>variables</code> <pre><code>{}\n</code></pre></p>"},{"location":"supabase/#supabase-js","title":"supabase-js","text":"<p>The JS ecosystem supports multiple prominent GraphQL frameworks. supabase-js is unopinionated about your GraphQL tooling and can integrate with all of them.</p> <p>For an example integration, check out the Relay guide, complete with Supabase Auth support.</p>"},{"location":"supabase/#graphiql","title":"GraphiQL","text":"<p>If you'd prefer to connect to Supabase GraphQL using an external IDE like GraphiQL, save the HTML snippet below as <code>supabase_graphiql.html</code> and open it in your browser. Be sure to substitute in your PROJECT_REF and API_KEY beneath the <code>EDIT BELOW</code> comment:</p> <pre><code>&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;GraphiQL&lt;/title&gt;\n    &lt;link href=\"https://cdnjs.cloudflare.com/ajax/libs/graphiql/2.4.7/graphiql.css\" rel=\"stylesheet\" /&gt;\n  &lt;/head&gt;\n  &lt;body style=\"margin: 0;\"&gt;\n    &lt;div id=\"graphiql\" style=\"height: 100vh;\"&gt;&lt;/div&gt;\n    &lt;script crossorigin src=\"https://unpkg.com/react@18/umd/react.production.min.js\"&gt;&lt;/script&gt;\n    &lt;script crossorigin src=\"https://unpkg.com/react-dom@18/umd/react-dom.production.min.js\"&gt;&lt;/script&gt;\n    &lt;script\n      crossorigin\n      src=\"https://cdnjs.cloudflare.com/ajax/libs/graphiql/2.4.7/graphiql.js\"\n    &gt;&lt;/script&gt;\n    &lt;script&gt;\n\n////////////////\n// EDIT BELOW //\n////////////////\n\nconst fetcher = GraphiQL.createFetcher({\nurl: 'https://&lt;PROJECT_REF&gt;.supabase.co/graphql/v1',\nheaders: {\n\"apiKey\": \"&lt;API_KEY&gt;\",\n}\n});\nReactDOM.render(\nReact.createElement(GraphiQL, { fetcher: fetcher }),\ndocument.getElementById('graphiql'),\n);\n&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"supabase/#schema-table-visibility","title":"Schema &amp; Table Visibility","text":"<p>pg_graphql uses Postgres' <code>search_path</code> and permissions system to determine which schemas and entities are exposed in the GraphQL schema. By default on Supabase, tables, views, and functions in the <code>public</code> schema are visible to anonymous (<code>anon</code>) and logged in (<code>authenticated</code>) roles.</p>"},{"location":"supabase/#remove-a-table-from-the-api","title":"Remove a Table from the API","text":"<p>To remove a table from the GraphQL API, you can revoke permission on that table from the the relevant role. For example, to remove table <code>foo</code> from the API for anonymous users you could run:</p> <pre><code>revoke all on table public.foo from anon;\n</code></pre> <p>You can similarly revoke permissions using the more granular <code>insert</code>, <code>update</code>, <code>delete</code>, and <code>truncate</code> permissions to remove individual entrypoints in the GraphQL API. For example, revoking <code>update</code> permission removes the <code>updateFooCollection</code> entrypoing in the API's <code>Mutation</code> type.</p>"},{"location":"supabase/#add-a-schema-to-the-api","title":"Add a Schema to the API","text":"<p>Adding a schema to the GraphQL API is a two step process.</p> <p>First, we need to add the new schema to the API search path. In the example below, we add a comma separated value for the new <code>app</code> schema:</p> <p></p> <p>Next, make sure the schema and entities (tables/views/functions) that you intend to expose are accessible by the relevant roles. For example, to match permissions from the public schema:</p> <pre><code>grant usage on app to anon, authenticated, service_role;\ngrant all on all tables in schema app to anon, authenticated, service_role;\ngrant all on all routines in schema app to anon, authenticated, service_role;\ngrant all on all sequences in schema app to anon, authenticated, service_role;\nalter default privileges for role postgres in schema app grant all on tables to anon, authenticated, service_role;\nalter default privileges for role postgres in schema app grant all on routines to anon, authenticated, service_role;\nalter default privileges for role postgres in schema app grant all on sequences to anon, authenticated, service_role;\n</code></pre> <p>Note that in practice you likely prefer a more secure set of permissions, particularly for anonymous API users.</p>"},{"location":"supabase/#version-management","title":"Version Management","text":"<p>To maximize stability, you are in control of when to upgrade your GraphQL API. To see which version of pg_graphql you have, and the highest upgrade version available, execute:</p> <pre><code>select * from pg_available_extensions where name = 'pg_graphql'\n</code></pre> <p>Which returns a table, for example:</p> name default_version installed_version comment pg_graphql 1.2.0 1.1.0 GraphQL support <p>The <code>default_version</code> is the highest version available on your database. The <code>installed_version</code> is the version currently enabled in your database. If the two differ, as in the example, you can upgrade your installed version by running:</p> <pre><code>drop extension pg_graphql;   -- drop version 1.1.0\ncreate extension pg_graphql; -- install default version 1.2.0\n</code></pre> <p>To upgrade your GraphQL API with 0 downtime.</p> <p>When making a decision to upgrade, you can review features of the upgraded version in the changelog.</p> <p>Always test a new version of pg_graphql extensively on a development or staging instance before updating your production instance. pg_graphql follows SemVer, which makes API backwards compatibility relatively safe for minor and patch updates. Even so, it's critical to verify that changes do not negatively impact the specifics of your project's API in other ways, e.g. requests/sec or CPU load.</p>"},{"location":"supabase/#local-development","title":"Local Development","text":"<p>When starting a local project through the Supabase CLI, the output of <code>supabase start</code> provides the information needed to call the GraphQL API directly. You can also use the Supabase Studio url to access the builtin GraphiQL IDE.</p> <pre><code>&gt; supabase start\n...\n\nStarted supabase local development setup.\n\n     GraphQL URL: http://localhost:54321/graphql/v1  &lt;-- GraphQL endpoint\n          DB URL: ...\n      Studio URL: http://localhost:54323             &lt;-- Supabase Studio\n    Inbucket URL: ...\n      JWT secret: ...\n        anon key: eyJhbGciOiJIUzI1...&lt;truncated&gt;     &lt;-- API_KEY\nservice_role key: ...\n</code></pre>"},{"location":"supabase/#term-reference","title":"Term Reference","text":""},{"location":"supabase/#project-reference-project_ref","title":"Project Reference (PROJECT_REF)","text":"<p>Your Supabase project reference or PROJECT_REF is a 20 digit unique identifier for your project, for example <code>bvykdyhlwawojivopztl</code>. The project reference is used throughout your supabase application including the project's API URL. You can find the project reference in by logging in to Supabase Studio and navigating to <code>Settings &gt; General &gt; Project Settings &gt; Reference ID</code></p> <p></p>"},{"location":"supabase/#api-key-api_key","title":"API Key (API_KEY)","text":"<p>Your Supabase API Key is a public value that must be sent with every API request. The key is visible in Supabase Studio at <code>Settings &gt; API &gt; Project API keys</code></p> <p></p>"},{"location":"usage_with_relay/","title":"Usage with Relay","text":"<p>pg_graphql implements the GraphQL Global Object Identification Specification (<code>Node</code> interface) and the GraphQL Cursor Connections Specification to be compatible with Relay.</p>"},{"location":"usage_with_relay/#relay-setup","title":"Relay Setup","text":""},{"location":"usage_with_relay/#pre-requisites","title":"Pre-requisites","text":"<p>Follow the Relay Installation Guide.</p>"},{"location":"usage_with_relay/#configuring-the-relay-compiler","title":"Configuring the Relay Compiler","text":"<p>Modify your <code>relay.config.js</code> file to reflect the following:</p> <pre><code>module.exports = {\n// standard relay config options\nsrc: './src',\nlanguage: 'typescript',\nschema: './data/schema.graphql',\nexclude: ['**/node_modules/**', '**/__mocks__/**', '**/__generated__/**'],\n// pg_graphql specific options\nschemaConfig: {\nnodeInterfaceIdField: 'nodeId',\nnodeInterfaceIdVariableName: 'nodeId',\n},\ncustomScalars: {\nUUID: 'string',\nDatetime: 'string',\nJSON: 'string',\nBigInt: 'string',\nBigFloat: 'string',\nOpaque: 'any',\n},\n}\n</code></pre> <ul> <li><code>schemaConfig</code> tells the Relay compiler where to find the <code>nodeId</code> field on the <code>node</code> interface</li> <li><code>customScalars</code> will improve Relay's type emission</li> </ul>"},{"location":"usage_with_relay/#configuring-your-relay-environment","title":"Configuring your Relay Environment","text":"<p>This example uses Supabase for the GraphQL server, but pg_graphql can be used independently.</p> <pre><code>import {\nEnvironment,\nFetchFunction,\nNetwork,\nRecordSource,\nStore,\n} from 'relay-runtime'\n\nimport supabase, { SUPABASE_ANON_KEY, SUPABASE_URL } from './supabase'\n\nconst fetchQuery: FetchFunction = async (operation, variables) =&gt; {\nconst {\ndata: { session },\n} = await supabase.auth.getSession()\n\nconst response = await fetch(`${SUPABASE_URL}/graphql/v1`, {\nmethod: 'POST',\nheaders: {\n'Content-Type': 'application/json',\napikey: SUPABASE_ANON_KEY,\nAuthorization: `Bearer ${session?.access_token ?? SUPABASE_ANON_KEY}`,\n},\nbody: JSON.stringify({\nquery: operation.text,\nvariables,\n}),\n})\n\nreturn await response.json()\n}\n\nconst network = Network.create(fetchQuery)\nconst store = new Store(new RecordSource())\n\nconst environment = new Environment({\nnetwork,\nstore,\ngetDataID: (node) =&gt; node.nodeId,\nmissingFieldHandlers: [\n{\nhandle(field, _record, argValues) {\nif (field.name === 'node' &amp;&amp; 'nodeId' in argValues) {\n// If field is node(nodeId: $nodeId), look up the record by the value of $nodeId\nreturn argValues.nodeId\n}\n\nreturn undefined\n},\nkind: 'linked',\n},\n],\n})\n\nexport default environment\n</code></pre> <ul> <li><code>getDataID</code> is the most important option to add, as it tells Relay how to store data correctly in the cache.</li> <li><code>missingFieldHandlers</code> is optional in this example but helps with Rendering Partially Cached Data.</li> </ul>"},{"location":"usage_with_relay/#pagination","title":"Pagination","text":"<p>Say you are working on a Todo app and want to add pagination. You can use <code>@connection</code> and <code>@prependNode</code> to do this.</p> <p>Fragment passed to <code>usePaginationFragment()</code></p> <pre><code>fragment TodoList_query on Query\n@argumentDefinitions(\n  cursor: { type: \"Cursor\" }\n  count: { type: \"Int\", defaultValue: 20 }\n)\n@refetchable(queryName: \"TodoListPaginationQuery\") {\n  todosCollection(after: $cursor, first: $count)\n    @connection(key: \"TodoList_query_todosCollection\") {\n    pageInfo {\n      hasNextPage\n      endCursor\n    }\n    edges {\n      cursor\n      node {\n        nodeId\n        ...TodoItem_todos\n      }\n    }\n  }\n}\n</code></pre> <p>Mutation to create a new Todo</p> <pre><code>mutation TodoCreateMutation($input: TodosInsertInput!, $connections: [ID!]!) {\n  insertIntoTodosCollection(objects: [$input]) {\n    affectedCount\n    records @prependNode(connections: $connections, edgeTypeName: \"TodosEdge\") {\n      ...TodoItem_todos\n    }\n  }\n}\n</code></pre> <p>Code to call the mutation</p> <pre><code>import { ConnectionHandler, graphql, useMutation } from 'react-relay'\n\n// inside a React component\nconst [todoCreateMutate, isMutationInFlight] =\nuseMutation&lt;TodoCreateMutation&gt;(CreateTodoMutation)\n\n// inside your create todo function\nconst connectionID = ConnectionHandler.getConnectionID(\n'root',\n'TodoList_query_todosCollection'\n)\n\ntodoCreateMutate({\nvariables: {\ninput: {\n// ...new todo data\n},\nconnections: [connectionID],\n},\n})\n</code></pre>"},{"location":"views/","title":"Views","text":"<p>Views, materialized views, and foreign tables can be exposed with pg_graphql.</p>"},{"location":"views/#primary-keys-required","title":"Primary Keys (Required)","text":"<p>A primary key is required for an entity to be reflected in the GraphQL schema. Tables can define primary keys with SQL DDL, but primary keys are not available for views, materialized views, or foreign tables. For those entities, you can set a \"fake\" primary key with a comment directive. <pre><code>{\"primary_key_columns\": [&lt;column_name_1&gt;, ..., &lt;column_name_n&gt;]}\n</code></pre></p> <p>For example:</p> <p><pre><code>create view \"Person\" as\nselect\nid,\nname\nfrom\n\"Account\";\n\ncomment on view \"Person\" is e'@graphql({\"primary_key_columns\": [\"id\"]})';\n</code></pre> tells pg_graphql to treat <code>\"Person\".id</code> as the primary key for the <code>Person</code> entity resulting in the following GraphQL type:</p> <pre><code>type Person {\n  nodeId: ID!\n  id: Int!\n  name: String!\n}\n</code></pre> <p>Warning</p> <p>Values of the primary key column/s must be unique within the table. If they are not unique, you will experience inconsistent behavior with <code>ID!</code> types, sorting, and pagination.</p> <p>Updatable views are reflected in the <code>Query</code> and <code>Mutation</code> types identically to tables. Non-updatable views are read-only and accessible via the <code>Query</code> type only.</p>"},{"location":"views/#relationships","title":"Relationships","text":"<p>pg_graphql identifies relationships among entities by inspecting foreign keys. Views, materialized views, and foreign tables do not support foreign keys. For this reason, relationships can also be defined in comment directive using the structure:</p> <pre><code>{\n\"foreign_keys\": [\n{\n\"local_name\": \"foo\", // optional\n\"local_columns\": [\"account_id\"],\n\"foreign_name\": \"bar\", // optional\n\"foreign_schema\": \"public\",\n\"foreign_table\": \"account\",\n\"foreign_columns\": [\"id\"]\n}\n]\n}\n</code></pre> <p>For example:</p> <p><pre><code>create table \"Account\"(\nid serial primary key,\nname text not null\n);\n\ncreate table \"EmailAddress\"(\nid serial primary key,\n\"accountId\" int not null, -- note: no foreign key\n\"isPrimary\" bool not null,\naddress text not null\n);\n\ncomment on table \"EmailAddress\" is e'\n    @graphql({\n        \"foreign_keys\": [\n          {\n            \"local_name\": \"addresses\",\n            \"local_columns\": [\"accountId\"],\n            \"foreign_name\": \"account\",\n            \"foreign_schema\": \"public\",\n            \"foreign_table\": \"Account\",\n            \"foreign_columns\": [\"id\"]\n          }\n        ]\n    })';\n</code></pre> defines a relationship equivalent to the following foreign key <pre><code>alter table \"EmailAddress\"\nadd constraint fkey_email_address_to_account\nforeign key (\"accountId\")\nreferences \"Account\" (\"id\");\n\ncomment on constraint fkey_email_address_to_account\non \"EmailAddress\"\nis E'@graphql({\"foreign_name\": \"account\", \"local_name\": \"addresses\"})';\n</code></pre></p> <p>yielding the GraphQL types:</p> <pre><code>type Account {\n  nodeId: ID!\n  id: Int!\n  name: String!\n  addresses(\n    after: Cursor,\n    before: Cursor,\n    filter: EmailAddressFilter,\n    first: Int,\n    last: Int,\n    orderBy: [EmailAddressOrderBy!]\n  ): EmailAddressConnection\n}\n\ntype EmailAddress {\n  nodeId: ID!\n  id: Int!\n  isPrimary: Boolean!\n  address: String!\n  accountId: Int!\n  account: Account!\n}\n</code></pre>"}]}