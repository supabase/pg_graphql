{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pg_graphql Documentation : https://supabase.github.io/pg_graphql Source Code : https://github.com/supabase/pg_graphql Query your existing PostgreSQL database with GraphQL pg_graphql inspects your PostgreSQL schema and reflects a GraphQL schema with resolvers. Performant : +2k requests/second Always up-to-date : Reflected from the SQL schema Pagination : Relay compliant Serverless : Runs in your database with no additional server required Open Source : Apache License 2.0 Warning pg_graphql is pre-alpha software under active development Motivation pg_graphql provides an SQL schema -> GraphQL schema reflection engine and an associated GraphQL query -> SQL query transpiler. The extension keeps schema generation, query parsing, and resolvers all neatly contained on your database. This enables any programming language that can connect to PostgreSQL to query the database via GraphQL with no additional servers, processes, or libraries. TL;DR The SQL schema 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 create table account ( id serial primary key , email varchar ( 255 ) not null , encrypted_password varchar ( 255 ) not null , created_at timestamp not null , updated_at timestamp not null ); create table blog ( id serial primary key , owner_id integer not null references account ( id ), name varchar ( 255 ) not null , description varchar ( 255 ), created_at timestamp not null , updated_at timestamp not null ); create type blog_post_status as enum ( 'PENDING' , 'RELEASED' ); create table blog_post ( id uuid not null default uuid_generate_v4 () primary key , blog_id integer not null references blog ( id ), title varchar ( 255 ) not null , body varchar ( 10000 ), status blog_post_status not null , created_at timestamp not null , updated_at timestamp not null ); Translates into a GraphQL schema exposing each table as a pageable collection with relationships defined by the foreign keys.","title":"Welcome"},{"location":"#pg_graphql","text":"Documentation : https://supabase.github.io/pg_graphql Source Code : https://github.com/supabase/pg_graphql Query your existing PostgreSQL database with GraphQL pg_graphql inspects your PostgreSQL schema and reflects a GraphQL schema with resolvers. Performant : +2k requests/second Always up-to-date : Reflected from the SQL schema Pagination : Relay compliant Serverless : Runs in your database with no additional server required Open Source : Apache License 2.0 Warning pg_graphql is pre-alpha software under active development","title":"pg_graphql"},{"location":"#motivation","text":"pg_graphql provides an SQL schema -> GraphQL schema reflection engine and an associated GraphQL query -> SQL query transpiler. The extension keeps schema generation, query parsing, and resolvers all neatly contained on your database. This enables any programming language that can connect to PostgreSQL to query the database via GraphQL with no additional servers, processes, or libraries.","title":"Motivation"},{"location":"#tldr","text":"The SQL schema 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 create table account ( id serial primary key , email varchar ( 255 ) not null , encrypted_password varchar ( 255 ) not null , created_at timestamp not null , updated_at timestamp not null ); create table blog ( id serial primary key , owner_id integer not null references account ( id ), name varchar ( 255 ) not null , description varchar ( 255 ), created_at timestamp not null , updated_at timestamp not null ); create type blog_post_status as enum ( 'PENDING' , 'RELEASED' ); create table blog_post ( id uuid not null default uuid_generate_v4 () primary key , blog_id integer not null references blog ( id ), title varchar ( 255 ) not null , body varchar ( 10000 ), status blog_post_status not null , created_at timestamp not null , updated_at timestamp not null ); Translates into a GraphQL schema exposing each table as a pageable collection with relationships defined by the foreign keys.","title":"TL;DR"},{"location":"api/","text":"The public API consists of a single function to resolve GraphQL queries. All other entities in the graphql schema are private. graphql.resolve description Resolves a GraphQL query, returning JSONB. signature 1 2 3 4 5 6 7 8 9 10 11 12 graphql . resolve ( -- the graphql query/mutation stmt text , -- json key/values pairs for variables variables jsonb default '{}' :: jsonb , ) returns jsonb strict volatile parallel safe language plpgsql usage 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 -- Setup graphqldb = create extension pg_graphql cascade ; CREATE EXTENSION graphqldb = create table book ( id int primary key , title text ); CREATE TABLE graphqldb = insert into book ( id , title ) values ( 1 , 'book 1' ); INSERT 0 1 -- Example graphqldb = select graphql . resolve ( $$ query { bookCollection { edges { node { id } } } } $$ ); resolve ---------------------------------------------------------------------- { \"data\" : { \"bookCollection\" : { \"edges\" : [ { \"node\" : { \"id\" : 1 }} ] }} , \"errors\" : [] }","title":"API"},{"location":"api/#graphqlresolve","text":"","title":"graphql.resolve"},{"location":"api/#description","text":"Resolves a GraphQL query, returning JSONB.","title":"description"},{"location":"api/#signature","text":"1 2 3 4 5 6 7 8 9 10 11 12 graphql . resolve ( -- the graphql query/mutation stmt text , -- json key/values pairs for variables variables jsonb default '{}' :: jsonb , ) returns jsonb strict volatile parallel safe language plpgsql","title":"signature"},{"location":"api/#usage","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 -- Setup graphqldb = create extension pg_graphql cascade ; CREATE EXTENSION graphqldb = create table book ( id int primary key , title text ); CREATE TABLE graphqldb = insert into book ( id , title ) values ( 1 , 'book 1' ); INSERT 0 1 -- Example graphqldb = select graphql . resolve ( $$ query { bookCollection { edges { node { id } } } } $$ ); resolve ---------------------------------------------------------------------- { \"data\" : { \"bookCollection\" : { \"edges\" : [ { \"node\" : { \"id\" : 1 }} ] }} , \"errors\" : [] }","title":"usage"},{"location":"computed_fields/","text":"PostgreSQL Builtin PostgreSQL has a builtin feature for adding generated columns to tables. Generated columns are reflected identically to non-generated columns. This is the reccomended approach to adding computed fields when your computation meets the restrictions. The most significant restrictions of generated columns are: expression must be immutable expression may only reference the current row For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 begin ; create table public . account ( id serial primary key , first_name varchar ( 255 ) not null , last_name varchar ( 255 ) not null , full_name text generated always as ( first_name || ' ' || last_name ) stored ); insert into public . account ( first_name , last_name ) values ( 'Foo' , 'Fooington' ); select jsonb_pretty ( graphql . resolve ( $$ { accountCollection { edges { node { id firstName lastName fullName } } } } $$ ) ); jsonb_pretty ------------------------------------------------------ { + \"data\" : { + \"accountCollection\" : { + \"edges\" : [ + { + \"node\" : { + \"id\" : 1 , + \"fullName\" : \"Foo Fooington\" , + \"lastName\" : \"Fooington\" , + \"firstName\" : \"Foo\" + } + } + ] + } + } , + \"errors\" : [ + ] + } ( 1 row ) rollback ; Extending Types with Functions For arbitrary computations that do not meet the requirements for generated columns , a table's reflected GraphQL type can be extended by creating a function that: accepts a single parameter of the table's tuple type has a name starting with an underscore 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 begin ; create table public . account ( id serial primary key , first_name varchar ( 255 ) not null , last_name varchar ( 255 ) not null , parent_id int references account ( id ) ); -- Extend with function create function public . _full_name ( rec public . account ) returns text immutable strict language sql as $$ select format ( '%s %s' , rec . first_name , rec . last_name ) $$ ; insert into public . account ( first_name , last_name , parent_id ) values ( 'Foo' , 'Fooington' , 1 ); select jsonb_pretty ( graphql . resolve ( $$ { accountCollection { edges { node { id firstName lastName fullName parent { fullName } } } } } $$ ) ); jsonb_pretty --------------------------------------------------------- { + \"data\" : { + \"accountCollection\" : { + \"edges\" : [ + { + \"node\" : { + \"id\" : 1 , + \"parent\" : { + \"fullName\" : \"Foo Fooington\" + } , + \"fullName\" : \"Foo Fooington\" , + \"lastName\" : \"Fooington\" , + \"firstName\" : \"Foo\" + } + } + ] + } + } , + \"errors\" : [ + ] + } ( 1 row ) rollback ;","title":"Computed Fields"},{"location":"computed_fields/#postgresql-builtin","text":"PostgreSQL has a builtin feature for adding generated columns to tables. Generated columns are reflected identically to non-generated columns. This is the reccomended approach to adding computed fields when your computation meets the restrictions. The most significant restrictions of generated columns are: expression must be immutable expression may only reference the current row For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 begin ; create table public . account ( id serial primary key , first_name varchar ( 255 ) not null , last_name varchar ( 255 ) not null , full_name text generated always as ( first_name || ' ' || last_name ) stored ); insert into public . account ( first_name , last_name ) values ( 'Foo' , 'Fooington' ); select jsonb_pretty ( graphql . resolve ( $$ { accountCollection { edges { node { id firstName lastName fullName } } } } $$ ) ); jsonb_pretty ------------------------------------------------------ { + \"data\" : { + \"accountCollection\" : { + \"edges\" : [ + { + \"node\" : { + \"id\" : 1 , + \"fullName\" : \"Foo Fooington\" , + \"lastName\" : \"Fooington\" , + \"firstName\" : \"Foo\" + } + } + ] + } + } , + \"errors\" : [ + ] + } ( 1 row ) rollback ;","title":"PostgreSQL Builtin"},{"location":"computed_fields/#extending-types-with-functions","text":"For arbitrary computations that do not meet the requirements for generated columns , a table's reflected GraphQL type can be extended by creating a function that: accepts a single parameter of the table's tuple type has a name starting with an underscore 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 begin ; create table public . account ( id serial primary key , first_name varchar ( 255 ) not null , last_name varchar ( 255 ) not null , parent_id int references account ( id ) ); -- Extend with function create function public . _full_name ( rec public . account ) returns text immutable strict language sql as $$ select format ( '%s %s' , rec . first_name , rec . last_name ) $$ ; insert into public . account ( first_name , last_name , parent_id ) values ( 'Foo' , 'Fooington' , 1 ); select jsonb_pretty ( graphql . resolve ( $$ { accountCollection { edges { node { id firstName lastName fullName parent { fullName } } } } } $$ ) ); jsonb_pretty --------------------------------------------------------- { + \"data\" : { + \"accountCollection\" : { + \"edges\" : [ + { + \"node\" : { + \"id\" : 1 , + \"parent\" : { + \"fullName\" : \"Foo Fooington\" + } , + \"fullName\" : \"Foo Fooington\" , + \"lastName\" : \"Fooington\" , + \"firstName\" : \"Foo\" + } + } + ] + } + } , + \"errors\" : [ + ] + } ( 1 row ) rollback ;","title":"Extending Types with Functions"},{"location":"configuration/","text":"Table/Column Visibility Table and column visibility in the GraphQL schema are controlled by standard PostgreSQL permissions. Revoking SELECT access from the user/role executing queries removes that entity from the visible schema. For example: 1 revoke all privileges on public . account from api_user ; removes the Account GraphQL type. Similarly, revoking SELECT access on a table's column will remove that field from the associated GraphQL type/s. The permissions SELECT , INSERT , UPDATE , and DELETE all impact the relevant sections of the GraphQL schema. Row Visibilty Visibility of rows in a given table can be configured using PostgreSQL's built-in row level security policies. Comment Directives Comment directives are snippets of configuration associated with SQL entities that alter if/how those entities are reflected into the GraphQL schema. The format of a comment directive is 1 @ graphql ( < JSON > ) Rename a Table's Type Use the \"name\" JSON key to override a table's type name. 1 2 3 4 5 6 create table account ( id serial primary key ); comment on table public . account is e '@graphql({\"name\": \"AccountHolder\"})' ; results in: 1 2 3 type AccountHolder { # previously: \"Account\" id: Int! } Rename a Column's Field Use the \"name\" JSON key to override a column's field name. 1 2 3 4 5 6 7 create table public . account ( id serial primary key , email text ); comment on column public . account . email is e '@graphql({\"name\": \"emailAddress\"})' ; results in: 1 2 3 4 type Account { id: Int! emailAddress: String! # previously \"email\" } Rename a Computed Field Use the \"name\" JSON key to override a computed field's name. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 create table public . account ( id serial primary key , first_name varchar ( 255 ) not null , last_name varchar ( 255 ) not null ); -- Extend with function create function public . _full_name ( rec public . account ) returns text immutable strict language sql as $$ select format ( '%s %s' , rec . first_name , rec . last_name ) $$ ; comment on function public . _full_name is e '@graphql({\"name\": \"displayName\"})' ; results in: 1 2 3 4 5 6 type Account { id: Int! firstName: String! lastName: String! displayName: String # previously \"fullName\" } Rename a Relationship's (Foreign Key) Field Use the \"local_name\" and \"foreign_name\" JSON keys to override a a relationships inbound and outbound field names. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 create table account ( id serial primary key ); create table post ( id serial primary key , account_id integer not null references account ( id ), title text not null , body text ); comment on constraint post_owner_id_fkey on post is E '@graphql({\"foreign_name\": \"author\", \"local_name\": \"posts\"})' ; results in: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 type Post { id: Int! accountId: Int! title: String! body: String! author: Account # was \"account\" } type Account { id: Int! posts( # was \"postCollection\" after: Cursor, before: Cursor, filter: PostFilter, first: Int, last: Int, orderBy: [PostOrderBy!] ): PostConnection }","title":"Configuration"},{"location":"configuration/#tablecolumn-visibility","text":"Table and column visibility in the GraphQL schema are controlled by standard PostgreSQL permissions. Revoking SELECT access from the user/role executing queries removes that entity from the visible schema. For example: 1 revoke all privileges on public . account from api_user ; removes the Account GraphQL type. Similarly, revoking SELECT access on a table's column will remove that field from the associated GraphQL type/s. The permissions SELECT , INSERT , UPDATE , and DELETE all impact the relevant sections of the GraphQL schema.","title":"Table/Column Visibility"},{"location":"configuration/#row-visibilty","text":"Visibility of rows in a given table can be configured using PostgreSQL's built-in row level security policies.","title":"Row Visibilty"},{"location":"configuration/#comment-directives","text":"Comment directives are snippets of configuration associated with SQL entities that alter if/how those entities are reflected into the GraphQL schema. The format of a comment directive is 1 @ graphql ( < JSON > )","title":"Comment Directives"},{"location":"configuration/#rename-a-tables-type","text":"Use the \"name\" JSON key to override a table's type name. 1 2 3 4 5 6 create table account ( id serial primary key ); comment on table public . account is e '@graphql({\"name\": \"AccountHolder\"})' ; results in: 1 2 3 type AccountHolder { # previously: \"Account\" id: Int! }","title":"Rename a Table's Type"},{"location":"configuration/#rename-a-columns-field","text":"Use the \"name\" JSON key to override a column's field name. 1 2 3 4 5 6 7 create table public . account ( id serial primary key , email text ); comment on column public . account . email is e '@graphql({\"name\": \"emailAddress\"})' ; results in: 1 2 3 4 type Account { id: Int! emailAddress: String! # previously \"email\" }","title":"Rename a Column's Field"},{"location":"configuration/#rename-a-computed-field","text":"Use the \"name\" JSON key to override a computed field's name. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 create table public . account ( id serial primary key , first_name varchar ( 255 ) not null , last_name varchar ( 255 ) not null ); -- Extend with function create function public . _full_name ( rec public . account ) returns text immutable strict language sql as $$ select format ( '%s %s' , rec . first_name , rec . last_name ) $$ ; comment on function public . _full_name is e '@graphql({\"name\": \"displayName\"})' ; results in: 1 2 3 4 5 6 type Account { id: Int! firstName: String! lastName: String! displayName: String # previously \"fullName\" }","title":"Rename a Computed Field"},{"location":"configuration/#rename-a-relationships-foreign-key-field","text":"Use the \"local_name\" and \"foreign_name\" JSON keys to override a a relationships inbound and outbound field names. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 create table account ( id serial primary key ); create table post ( id serial primary key , account_id integer not null references account ( id ), title text not null , body text ); comment on constraint post_owner_id_fkey on post is E '@graphql({\"foreign_name\": \"author\", \"local_name\": \"posts\"})' ; results in: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 type Post { id: Int! accountId: Int! title: String! body: String! author: Account # was \"account\" } type Account { id: Int! posts( # was \"postCollection\" after: Cursor, before: Cursor, filter: PostFilter, first: Int, last: Int, orderBy: [PostOrderBy!] ): PostConnection }","title":"Rename a Relationship's (Foreign Key) Field"},{"location":"contributing/","text":"pg_graphql is OSS. PR and issues are welcome. Development Nix is required to set up the environment. Testing Tests are located in ./test/sql with expected output in ./test/expected To run tests locally, execute: 1 2 # might take a few minutes downloading dependencies on the first run $ nix-shell --run \"pg_13_graphql make installcheck\" Interactive PSQL Development To reduce the iteration cycle, you may want to launch a psql prompt with pg_graphql installed to experiment 1 nix-shell --run \"pg_13_graphql psql\" Try out the commands below to spin up a database with the extension installed & query a table using GraphQL. Experiment with aliasing field/table names and filtering on different columns. 1 2 3 4 5 6 7 8 graphqldb = create extension pg_graphql cascade ; CREATE EXTENSION graphqldb = create table book ( id int primary key , title text ); CREATE TABLE graphqldb = insert into book ( id , title ) values ( 1 , 'book 1' ); INSERT 0 1 Finally, execute some graphql queries against the table. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 graphqldb = select graphql . resolve ( $$ query { bookCollection { edges { node { id } } } } $$ ); resolve ---------------------------------------------------------------------- { \"data\" : { \"bookCollection\" : { \"edges\" : [ { \"node\" : { \"id\" : 1 }} ] }} , \"errors\" : [] } Documentation All public API must be documented. Building documentation requires python 3.6+ Install Dependencies Install mkdocs, themes, and extensions. 1 pip install -r docs/requirements_docs.txt Serving To serve the documentation locally run 1 mkdocs serve and visit the docs at http://127.0.0.1:8000/pg_graphql/","title":"Contributing"},{"location":"contributing/#development","text":"Nix is required to set up the environment.","title":"Development"},{"location":"contributing/#testing","text":"Tests are located in ./test/sql with expected output in ./test/expected To run tests locally, execute: 1 2 # might take a few minutes downloading dependencies on the first run $ nix-shell --run \"pg_13_graphql make installcheck\"","title":"Testing"},{"location":"contributing/#interactive-psql-development","text":"To reduce the iteration cycle, you may want to launch a psql prompt with pg_graphql installed to experiment 1 nix-shell --run \"pg_13_graphql psql\" Try out the commands below to spin up a database with the extension installed & query a table using GraphQL. Experiment with aliasing field/table names and filtering on different columns. 1 2 3 4 5 6 7 8 graphqldb = create extension pg_graphql cascade ; CREATE EXTENSION graphqldb = create table book ( id int primary key , title text ); CREATE TABLE graphqldb = insert into book ( id , title ) values ( 1 , 'book 1' ); INSERT 0 1 Finally, execute some graphql queries against the table. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 graphqldb = select graphql . resolve ( $$ query { bookCollection { edges { node { id } } } } $$ ); resolve ---------------------------------------------------------------------- { \"data\" : { \"bookCollection\" : { \"edges\" : [ { \"node\" : { \"id\" : 1 }} ] }} , \"errors\" : [] }","title":"Interactive PSQL Development"},{"location":"contributing/#documentation","text":"All public API must be documented. Building documentation requires python 3.6+","title":"Documentation"},{"location":"contributing/#install-dependencies","text":"Install mkdocs, themes, and extensions. 1 pip install -r docs/requirements_docs.txt","title":"Install Dependencies"},{"location":"contributing/#serving","text":"To serve the documentation locally run 1 mkdocs serve and visit the docs at http://127.0.0.1:8000/pg_graphql/","title":"Serving"},{"location":"installation/","text":"Tested with PostgreSQL 13. Direct Server Access First, install libgraphqlparser Then clone the repo and install using 1 2 3 git clone https://github.com/supabase/pg_graphql.git cd pg_graphql make install To enable the extension in PostgreSQL we must execute a create extension statement. The extension creates its own schema/namespace named graphql to avoid naming conflicts. 1 create extension pg_graphql cascade ; Hosted Databases e.g. RDS, Cloud SQL Hosted database vendors do not provide the level of server access required to install pg_graphql at this time. Given that third-party hosted databases are increasingly common, we are exploring including SQL implementations of pg_graphql 's C components so it can be installed as a single-file SQL script. Stay tuned","title":"Installation"},{"location":"installation/#direct-server-access","text":"First, install libgraphqlparser Then clone the repo and install using 1 2 3 git clone https://github.com/supabase/pg_graphql.git cd pg_graphql make install To enable the extension in PostgreSQL we must execute a create extension statement. The extension creates its own schema/namespace named graphql to avoid naming conflicts. 1 create extension pg_graphql cascade ;","title":"Direct Server Access"},{"location":"installation/#hosted-databases-eg-rds-cloud-sql","text":"Hosted database vendors do not provide the level of server access required to install pg_graphql at this time. Given that third-party hosted databases are increasingly common, we are exploring including SQL implementations of pg_graphql 's C components so it can be installed as a single-file SQL script. Stay tuned","title":"Hosted Databases e.g. RDS, Cloud SQL"},{"location":"performance/","text":"On a machine with: 4 CPUs 16GB of RAM PostgreSQL 13 (docker) Postgrest +8 (docker, operating as webserver) pg_graphql served a simple query at an average rate of +2200 req/second. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 This is ApacheBench, Version 2.3 <$Revision: 1843412 $> Benchmarking 0.0.0.0 (be patient) Finished 8000 requests Server Software: postgrest/8.0.0 Server Hostname: 0.0.0.0 Server Port: 3000 Document Path: /rpc/graphql Document Length: 46 bytes Concurrency Level: 8 Time taken for tests: 3.628 seconds Complete requests: 8000 Failed requests: 0 Total transferred: 1768000 bytes Total body sent: 1928000 HTML transferred: 368000 bytes Requests per second: 2205.21 [#/sec] (mean) Time per request: 3.628 [ms] (mean) Time per request: 0.453 [ms] (mean, across all concurrent requests) Transfer rate: 475.93 [Kbytes/sec] received 519.00 kb/s sent 994.93 kb/s total Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 0.1 0 2 Processing: 1 4 3.7 2 39 Waiting: 0 3 3.6 2 39 Total: 1 4 3.7 2 39 Percentage of the requests served within a certain time (ms) 50% 2 66% 3 75% 3 80% 4 90% 7 95% 10 98% 15 99% 22 100% 39 (longest request) To reproduce this result, start the demo described in the quickstart guide and apache bench on a sample query. i.e. 1 2 3 4 5 docker-compose up echo '{\"query\": \"{ account(nodeId: $nodeId) { id }}\", \"variables\": {\"nodeId\": \"WyJhY2NvdW50IiwgMV0=\"}}' > query.json ab -n 8000 -c 8 -T application/json -p query.json http://0.0.0.0:3000/rpc/graphql","title":"Performance"},{"location":"quickstart/","text":"If you are new to the project, start here. The easiest way to try pg_graphql is to run the interactive GraphiQL IDE demo. The demo environment launches a database, webserver and the GraphiQL IDE/API explorer with a small pre-populated schema. Requires: git docker-compose First, clone the repo 1 2 git clone https://github.com/supabase/pg_graphql.git cd pg_graphql Next, launch the demo with docker-compose. 1 docker-compose up Finally, access GraphiQL at http://localhost:4000/ .","title":"Quickstart"},{"location":"reflection/","text":"SQL tables are reflected into GraphQL types with columns and foreign keys represented as fields on those types. Naming PostgreSQL tables/column names are automatically converted to pascal case for type names and camel case for field names. For example, an account table has GraphQL type name Account and can be queried via the accountCollection field of the Query type. Table, column, and relationship type and field names may be manually overridden as needed. Type Conversion Connection Types Connection types hande pagination best practices according to the relay spec . pg_graphql paginates via keyset pagination to enable consistent retrival times on every page. Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 create table account ( id serial primary key , email varchar ( 255 ) not null , encrypted_password varchar ( 255 ) not null , created_at timestamp not null , updated_at timestamp not null ); create table blog ( id serial primary key , owner_id integer not null references account ( id ), name varchar ( 255 ) not null , description varchar ( 255 ), created_at timestamp not null , updated_at timestamp not null ); create type blog_post_status as enum ( 'PENDING' , 'RELEASED' ); create table blog_post ( id uuid not null default uuid_generate_v4 () primary key , blog_id integer not null references blog ( id ), title varchar ( 255 ) not null , body varchar ( 10000 ), status blog_post_status not null , created_at timestamp not null , updated_at timestamp not null ); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 type Account { id: Int! email: String! encryptedPassword: String! createdAt: DateTime! updatedAt: DateTime! blogCollection( \"\"\"Query the first `n` records in the collection\"\"\" first: Int \"\"\"Query the last `n` records in the collection\"\"\" last: Int \"\"\"Query values in the collection before the provided cursor\"\"\" before: Cursor \"\"\"Query values in the collection after the provided cursor\"\"\" after: Cursor \"\"\"Filters to apply to the results set when querying from the collection\"\"\" filter: BlogFilter \"\"\"Sort order to apply to the collection\"\"\" orderBy: [BlogOrderBy!] ): BlogConnection } type AccountConnection { edges: [AccountEdge!]! pageInfo: PageInfo! totalCount: Int! } input AccountCreateInput { email: String encryptedPassword: String createdAt: DateTime updatedAt: DateTime } type AccountEdge { cursor: String! node: Account } input AccountFilter { id: IntFilter email: StringFilter encryptedPassword: StringFilter createdAt: DateTimeFilter updatedAt: DateTimeFilter } input AccountOrderBy { id: OrderByDirection email: OrderByDirection encryptedPassword: OrderByDirection createdAt: OrderByDirection updatedAt: OrderByDirection } input AccountUpdateInput { email: String encryptedPassword: String createdAt: DateTime updatedAt: DateTime } scalar BigInt \"\"\" Boolean expression comparing fields on type \"BigInt\" \"\"\" input BigIntFilter { eq: BigInt } type Blog { id: Int! ownerId: Int! name: String! description: String createdAt: DateTime! updatedAt: DateTime! blogPostCollection( \"\"\"Query the first `n` records in the collection\"\"\" first: Int \"\"\"Query the last `n` records in the collection\"\"\" last: Int \"\"\"Query values in the collection before the provided cursor\"\"\" before: Cursor \"\"\"Query values in the collection after the provided cursor\"\"\" after: Cursor \"\"\"Filters to apply to the results set when querying from the collection\"\"\" filter: BlogPostFilter \"\"\"Sort order to apply to the collection\"\"\" orderBy: [BlogPostOrderBy!] ): BlogPostConnection owner: Account } type BlogConnection { edges: [BlogEdge!]! pageInfo: PageInfo! totalCount: Int! } input BlogCreateInput { ownerId: Int name: String description: String createdAt: DateTime updatedAt: DateTime } type BlogEdge { cursor: String! node: Blog } input BlogFilter { id: IntFilter ownerId: IntFilter name: StringFilter description: StringFilter createdAt: DateTimeFilter updatedAt: DateTimeFilter } input BlogOrderBy { id: OrderByDirection ownerId: OrderByDirection name: OrderByDirection description: OrderByDirection createdAt: OrderByDirection updatedAt: OrderByDirection } type BlogPost { id: UUID! blogId: Int! title: String! body: String status: String! createdAt: DateTime! updatedAt: DateTime! blog: Blog } type BlogPostConnection { edges: [BlogPostEdge!]! pageInfo: PageInfo! totalCount: Int! } input BlogPostCreateInput { id: UUID blogId: Int title: String body: String status: String createdAt: DateTime updatedAt: DateTime } type BlogPostEdge { cursor: String! node: BlogPost } input BlogPostFilter { id: UUIDFilter blogId: IntFilter title: StringFilter body: StringFilter status: StringFilter createdAt: DateTimeFilter updatedAt: DateTimeFilter } input BlogPostOrderBy { id: OrderByDirection blogId: OrderByDirection title: OrderByDirection body: OrderByDirection status: OrderByDirection createdAt: OrderByDirection updatedAt: OrderByDirection } enum BlogPostStatus { PENDING RELEASED } input BlogPostUpdateInput { id: UUID blogId: Int title: String body: String status: String createdAt: DateTime updatedAt: DateTime } input BlogUpdateInput { ownerId: Int name: String description: String createdAt: DateTime updatedAt: DateTime } \"\"\" Boolean expression comparing fields on type \"Boolean\" \"\"\" input BooleanFilter { eq: Boolean } scalar Cursor scalar DateTime \"\"\" Boolean expression comparing fields on type \"DateTime\" \"\"\" input DateTimeFilter { eq: DateTime } \"\"\" Boolean expression comparing fields on type \"Float\" \"\"\" input FloatFilter { eq: Float } \"\"\" Boolean expression comparing fields on type \"Int\" \"\"\" input IntFilter { eq: Int } scalar JSON \"\"\" Boolean expression comparing fields on type \"JSON\" \"\"\" input JSONFilter { eq: JSON } \"\"\"The root type for creating and mutating data\"\"\" type Mutation { \"\"\"Creates a single `Account`\"\"\" createAccount(object: AccountCreateInput!): Account \"\"\"Creates a single `Blog`\"\"\" createBlog(object: BlogCreateInput!): Blog \"\"\"Creates a single `BlogPost`\"\"\" createBlogPost(object: BlogPostCreateInput!): BlogPost \"\"\"Deletes zero or more `Account` from the collection \"\"\" deleteFromAccountCollection( \"\"\"Restricts the mutation's impact to records matching the critera\"\"\" filter: AccountFilter \"\"\" The maximum number of records in the collection permitted to be affected \"\"\" atMost: Int! = 1 ): [Account!]! \"\"\"Deletes zero or more `Blog` from the collection \"\"\" deleteFromBlogCollection( \"\"\"Restricts the mutation's impact to records matching the critera\"\"\" filter: BlogFilter \"\"\" The maximum number of records in the collection permitted to be affected \"\"\" atMost: Int! = 1 ): [Blog!]! \"\"\"Deletes zero or more `BlogPost` from the collection \"\"\" deleteFromBlogPostCollection( \"\"\"Restricts the mutation's impact to records matching the critera\"\"\" filter: BlogPostFilter \"\"\" The maximum number of records in the collection permitted to be affected \"\"\" atMost: Int! = 1 ): [BlogPost!]! \"\"\"Updates zero or more `Account` in the collection\"\"\" updateAccountCollection( \"\"\" Fields that are set will be updated for all records matching the `filter` \"\"\" set: AccountUpdateInput! \"\"\"Restricts the mutation's impact to records matching the critera\"\"\" filter: AccountFilter \"\"\" The maximum number of records in the collection permitted to be affected \"\"\" atMost: Int! = 1 ): [Account!]! \"\"\"Updates zero or more `Blog` in the collection\"\"\" updateBlogCollection( \"\"\" Fields that are set will be updated for all records matching the `filter` \"\"\" set: BlogUpdateInput! \"\"\"Restricts the mutation's impact to records matching the critera\"\"\" filter: BlogFilter \"\"\" The maximum number of records in the collection permitted to be affected \"\"\" atMost: Int! = 1 ): [Blog!]! \"\"\"Updates zero or more `BlogPost` in the collection\"\"\" updateBlogPostCollection( \"\"\" Fields that are set will be updated for all records matching the `filter` \"\"\" set: BlogPostUpdateInput! \"\"\"Restricts the mutation's impact to records matching the critera\"\"\" filter: BlogPostFilter \"\"\" The maximum number of records in the collection permitted to be affected \"\"\" atMost: Int! = 1 ): [BlogPost!]! } \"\"\"Defines a per-field sorting order\"\"\" enum OrderByDirection { AscNullsFirst AscNullsLast DescNullsFirst DescNullsLast } type PageInfo { endCursor: String! hasNextPage: Boolean! hasPreviousPage: Boolean! startCursor: String! } \"\"\"The root type for querying data\"\"\" type Query { \"\"\"A pagable collection of type `Account`\"\"\" accountCollection( \"\"\"Query the first `n` records in the collection\"\"\" first: Int \"\"\"Query the last `n` records in the collection\"\"\" last: Int \"\"\"Query values in the collection before the provided cursor\"\"\" before: Cursor \"\"\"Query values in the collection after the provided cursor\"\"\" after: Cursor \"\"\"Filters to apply to the results set when querying from the collection\"\"\" filter: AccountFilter \"\"\"Sort order to apply to the collection\"\"\" orderBy: [AccountOrderBy!] ): AccountConnection \"\"\"A pagable collection of type `Blog`\"\"\" blogCollection( \"\"\"Query the first `n` records in the collection\"\"\" first: Int \"\"\"Query the last `n` records in the collection\"\"\" last: Int \"\"\"Query values in the collection before the provided cursor\"\"\" before: Cursor \"\"\"Query values in the collection after the provided cursor\"\"\" after: Cursor \"\"\"Filters to apply to the results set when querying from the collection\"\"\" filter: BlogFilter \"\"\"Sort order to apply to the collection\"\"\" orderBy: [BlogOrderBy!] ): BlogConnection \"\"\"A pagable collection of type `BlogPost`\"\"\" blogPostCollection( \"\"\"Query the first `n` records in the collection\"\"\" first: Int \"\"\"Query the last `n` records in the collection\"\"\" last: Int \"\"\"Query values in the collection before the provided cursor\"\"\" before: Cursor \"\"\"Query values in the collection after the provided cursor\"\"\" after: Cursor \"\"\"Filters to apply to the results set when querying from the collection\"\"\" filter: BlogPostFilter \"\"\"Sort order to apply to the collection\"\"\" orderBy: [BlogPostOrderBy!] ): BlogPostConnection } \"\"\" Boolean expression comparing fields on type \"String\" \"\"\" input StringFilter { eq: String } scalar UUID \"\"\" Boolean expression comparing fields on type \"UUID\" \"\"\" input UUIDFilter { eq: UUID }","title":"Reflection"},{"location":"reflection/#naming","text":"PostgreSQL tables/column names are automatically converted to pascal case for type names and camel case for field names. For example, an account table has GraphQL type name Account and can be queried via the accountCollection field of the Query type. Table, column, and relationship type and field names may be manually overridden as needed.","title":"Naming"},{"location":"reflection/#type-conversion","text":"","title":"Type Conversion"},{"location":"reflection/#connection-types","text":"Connection types hande pagination best practices according to the relay spec . pg_graphql paginates via keyset pagination to enable consistent retrival times on every page.","title":"Connection Types"},{"location":"reflection/#example","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 create table account ( id serial primary key , email varchar ( 255 ) not null , encrypted_password varchar ( 255 ) not null , created_at timestamp not null , updated_at timestamp not null ); create table blog ( id serial primary key , owner_id integer not null references account ( id ), name varchar ( 255 ) not null , description varchar ( 255 ), created_at timestamp not null , updated_at timestamp not null ); create type blog_post_status as enum ( 'PENDING' , 'RELEASED' ); create table blog_post ( id uuid not null default uuid_generate_v4 () primary key , blog_id integer not null references blog ( id ), title varchar ( 255 ) not null , body varchar ( 10000 ), status blog_post_status not null , created_at timestamp not null , updated_at timestamp not null ); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 type Account { id: Int! email: String! encryptedPassword: String! createdAt: DateTime! updatedAt: DateTime! blogCollection( \"\"\"Query the first `n` records in the collection\"\"\" first: Int \"\"\"Query the last `n` records in the collection\"\"\" last: Int \"\"\"Query values in the collection before the provided cursor\"\"\" before: Cursor \"\"\"Query values in the collection after the provided cursor\"\"\" after: Cursor \"\"\"Filters to apply to the results set when querying from the collection\"\"\" filter: BlogFilter \"\"\"Sort order to apply to the collection\"\"\" orderBy: [BlogOrderBy!] ): BlogConnection } type AccountConnection { edges: [AccountEdge!]! pageInfo: PageInfo! totalCount: Int! } input AccountCreateInput { email: String encryptedPassword: String createdAt: DateTime updatedAt: DateTime } type AccountEdge { cursor: String! node: Account } input AccountFilter { id: IntFilter email: StringFilter encryptedPassword: StringFilter createdAt: DateTimeFilter updatedAt: DateTimeFilter } input AccountOrderBy { id: OrderByDirection email: OrderByDirection encryptedPassword: OrderByDirection createdAt: OrderByDirection updatedAt: OrderByDirection } input AccountUpdateInput { email: String encryptedPassword: String createdAt: DateTime updatedAt: DateTime } scalar BigInt \"\"\" Boolean expression comparing fields on type \"BigInt\" \"\"\" input BigIntFilter { eq: BigInt } type Blog { id: Int! ownerId: Int! name: String! description: String createdAt: DateTime! updatedAt: DateTime! blogPostCollection( \"\"\"Query the first `n` records in the collection\"\"\" first: Int \"\"\"Query the last `n` records in the collection\"\"\" last: Int \"\"\"Query values in the collection before the provided cursor\"\"\" before: Cursor \"\"\"Query values in the collection after the provided cursor\"\"\" after: Cursor \"\"\"Filters to apply to the results set when querying from the collection\"\"\" filter: BlogPostFilter \"\"\"Sort order to apply to the collection\"\"\" orderBy: [BlogPostOrderBy!] ): BlogPostConnection owner: Account } type BlogConnection { edges: [BlogEdge!]! pageInfo: PageInfo! totalCount: Int! } input BlogCreateInput { ownerId: Int name: String description: String createdAt: DateTime updatedAt: DateTime } type BlogEdge { cursor: String! node: Blog } input BlogFilter { id: IntFilter ownerId: IntFilter name: StringFilter description: StringFilter createdAt: DateTimeFilter updatedAt: DateTimeFilter } input BlogOrderBy { id: OrderByDirection ownerId: OrderByDirection name: OrderByDirection description: OrderByDirection createdAt: OrderByDirection updatedAt: OrderByDirection } type BlogPost { id: UUID! blogId: Int! title: String! body: String status: String! createdAt: DateTime! updatedAt: DateTime! blog: Blog } type BlogPostConnection { edges: [BlogPostEdge!]! pageInfo: PageInfo! totalCount: Int! } input BlogPostCreateInput { id: UUID blogId: Int title: String body: String status: String createdAt: DateTime updatedAt: DateTime } type BlogPostEdge { cursor: String! node: BlogPost } input BlogPostFilter { id: UUIDFilter blogId: IntFilter title: StringFilter body: StringFilter status: StringFilter createdAt: DateTimeFilter updatedAt: DateTimeFilter } input BlogPostOrderBy { id: OrderByDirection blogId: OrderByDirection title: OrderByDirection body: OrderByDirection status: OrderByDirection createdAt: OrderByDirection updatedAt: OrderByDirection } enum BlogPostStatus { PENDING RELEASED } input BlogPostUpdateInput { id: UUID blogId: Int title: String body: String status: String createdAt: DateTime updatedAt: DateTime } input BlogUpdateInput { ownerId: Int name: String description: String createdAt: DateTime updatedAt: DateTime } \"\"\" Boolean expression comparing fields on type \"Boolean\" \"\"\" input BooleanFilter { eq: Boolean } scalar Cursor scalar DateTime \"\"\" Boolean expression comparing fields on type \"DateTime\" \"\"\" input DateTimeFilter { eq: DateTime } \"\"\" Boolean expression comparing fields on type \"Float\" \"\"\" input FloatFilter { eq: Float } \"\"\" Boolean expression comparing fields on type \"Int\" \"\"\" input IntFilter { eq: Int } scalar JSON \"\"\" Boolean expression comparing fields on type \"JSON\" \"\"\" input JSONFilter { eq: JSON } \"\"\"The root type for creating and mutating data\"\"\" type Mutation { \"\"\"Creates a single `Account`\"\"\" createAccount(object: AccountCreateInput!): Account \"\"\"Creates a single `Blog`\"\"\" createBlog(object: BlogCreateInput!): Blog \"\"\"Creates a single `BlogPost`\"\"\" createBlogPost(object: BlogPostCreateInput!): BlogPost \"\"\"Deletes zero or more `Account` from the collection \"\"\" deleteFromAccountCollection( \"\"\"Restricts the mutation's impact to records matching the critera\"\"\" filter: AccountFilter \"\"\" The maximum number of records in the collection permitted to be affected \"\"\" atMost: Int! = 1 ): [Account!]! \"\"\"Deletes zero or more `Blog` from the collection \"\"\" deleteFromBlogCollection( \"\"\"Restricts the mutation's impact to records matching the critera\"\"\" filter: BlogFilter \"\"\" The maximum number of records in the collection permitted to be affected \"\"\" atMost: Int! = 1 ): [Blog!]! \"\"\"Deletes zero or more `BlogPost` from the collection \"\"\" deleteFromBlogPostCollection( \"\"\"Restricts the mutation's impact to records matching the critera\"\"\" filter: BlogPostFilter \"\"\" The maximum number of records in the collection permitted to be affected \"\"\" atMost: Int! = 1 ): [BlogPost!]! \"\"\"Updates zero or more `Account` in the collection\"\"\" updateAccountCollection( \"\"\" Fields that are set will be updated for all records matching the `filter` \"\"\" set: AccountUpdateInput! \"\"\"Restricts the mutation's impact to records matching the critera\"\"\" filter: AccountFilter \"\"\" The maximum number of records in the collection permitted to be affected \"\"\" atMost: Int! = 1 ): [Account!]! \"\"\"Updates zero or more `Blog` in the collection\"\"\" updateBlogCollection( \"\"\" Fields that are set will be updated for all records matching the `filter` \"\"\" set: BlogUpdateInput! \"\"\"Restricts the mutation's impact to records matching the critera\"\"\" filter: BlogFilter \"\"\" The maximum number of records in the collection permitted to be affected \"\"\" atMost: Int! = 1 ): [Blog!]! \"\"\"Updates zero or more `BlogPost` in the collection\"\"\" updateBlogPostCollection( \"\"\" Fields that are set will be updated for all records matching the `filter` \"\"\" set: BlogPostUpdateInput! \"\"\"Restricts the mutation's impact to records matching the critera\"\"\" filter: BlogPostFilter \"\"\" The maximum number of records in the collection permitted to be affected \"\"\" atMost: Int! = 1 ): [BlogPost!]! } \"\"\"Defines a per-field sorting order\"\"\" enum OrderByDirection { AscNullsFirst AscNullsLast DescNullsFirst DescNullsLast } type PageInfo { endCursor: String! hasNextPage: Boolean! hasPreviousPage: Boolean! startCursor: String! } \"\"\"The root type for querying data\"\"\" type Query { \"\"\"A pagable collection of type `Account`\"\"\" accountCollection( \"\"\"Query the first `n` records in the collection\"\"\" first: Int \"\"\"Query the last `n` records in the collection\"\"\" last: Int \"\"\"Query values in the collection before the provided cursor\"\"\" before: Cursor \"\"\"Query values in the collection after the provided cursor\"\"\" after: Cursor \"\"\"Filters to apply to the results set when querying from the collection\"\"\" filter: AccountFilter \"\"\"Sort order to apply to the collection\"\"\" orderBy: [AccountOrderBy!] ): AccountConnection \"\"\"A pagable collection of type `Blog`\"\"\" blogCollection( \"\"\"Query the first `n` records in the collection\"\"\" first: Int \"\"\"Query the last `n` records in the collection\"\"\" last: Int \"\"\"Query values in the collection before the provided cursor\"\"\" before: Cursor \"\"\"Query values in the collection after the provided cursor\"\"\" after: Cursor \"\"\"Filters to apply to the results set when querying from the collection\"\"\" filter: BlogFilter \"\"\"Sort order to apply to the collection\"\"\" orderBy: [BlogOrderBy!] ): BlogConnection \"\"\"A pagable collection of type `BlogPost`\"\"\" blogPostCollection( \"\"\"Query the first `n` records in the collection\"\"\" first: Int \"\"\"Query the last `n` records in the collection\"\"\" last: Int \"\"\"Query values in the collection before the provided cursor\"\"\" before: Cursor \"\"\"Query values in the collection after the provided cursor\"\"\" after: Cursor \"\"\"Filters to apply to the results set when querying from the collection\"\"\" filter: BlogPostFilter \"\"\"Sort order to apply to the collection\"\"\" orderBy: [BlogPostOrderBy!] ): BlogPostConnection } \"\"\" Boolean expression comparing fields on type \"String\" \"\"\" input StringFilter { eq: String } scalar UUID \"\"\" Boolean expression comparing fields on type \"UUID\" \"\"\" input UUIDFilter { eq: UUID }","title":"Example"},{"location":"roadmap/","text":"pg_graphql aims to implement all of the GraphQL core specification and as much of the relay server specification as is practical. Language Parser Fragments Variables Named Operations Introspection Schema At time of writing, the introspection schema is a partial implementation. It is complete enough to render the GraphiQL explorer & to dump the schema via the Apollo CLI. Relay Opaque Cursors Global NodeId Node Types Arguments nodeId Connection Types totalCount PageInfo hasNextPage hasPreviousPage startCursor endCursor Edges cursor Pagination Arguments first last before after filter orderBy Relationships One-to-Many Many-to-Many Many-to-One One-to-One Mutations Upsert User Defined Functions Error Handling Display parser syntax errors Useful error on non-existent field Configuration Role based schema/table/column exclusion Override Type/Field names Optimizations Prepared statement query cached","title":"Roadmap"},{"location":"roadmap/#language","text":"Parser Fragments Variables Named Operations Introspection Schema At time of writing, the introspection schema is a partial implementation. It is complete enough to render the GraphiQL explorer & to dump the schema via the Apollo CLI.","title":"Language"},{"location":"roadmap/#relay","text":"Opaque Cursors Global NodeId Node Types Arguments nodeId Connection Types totalCount PageInfo hasNextPage hasPreviousPage startCursor endCursor Edges cursor Pagination Arguments first last before after filter orderBy","title":"Relay"},{"location":"roadmap/#relationships","text":"One-to-Many Many-to-Many Many-to-One One-to-One","title":"Relationships"},{"location":"roadmap/#mutations","text":"Upsert User Defined Functions","title":"Mutations"},{"location":"roadmap/#error-handling","text":"Display parser syntax errors Useful error on non-existent field","title":"Error Handling"},{"location":"roadmap/#configuration","text":"Role based schema/table/column exclusion Override Type/Field names","title":"Configuration"},{"location":"roadmap/#optimizations","text":"Prepared statement query cached","title":"Optimizations"}]}